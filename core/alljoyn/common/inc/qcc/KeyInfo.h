# Contributed by Qualcomm Connected Experiences, Inc.,
# with authorization from the AllSeen Alliance, Inc.
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# 
# Pursuant to Section 1 of the License, the work of authorship constituting
# a Work and any Contribution incorporated in the Work shall mean only that
# Contributor's code submissions authored by that Contributor.  Any rights
# granted under the License are conditioned upon acceptance of these
# clarifications.
#ifndef _QCC_KEYINFO_H
#define _QCC_KEYINFO_H
/**
 * @file
 *
 * This file provide public key info
 */

/******************************************************************************
 * Copyright (c) 2014, AllSeen Alliance. All rights reserved.
 *
 *    Contributed by Qualcomm Connected Experiences, Inc.,
 *    with authorization from the AllSeen Alliance, Inc.
 *    
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *    
 *        http://www.apache.org/licenses/LICENSE-2.0
 *    
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 *    
 *    Pursuant to Section 1 of the License, the work of authorship constituting
 *    a Work and any Contribution incorporated in the Work shall mean only that
 *    Contributor's code submissions authored by that Contributor.  Any rights
 *    granted under the License are conditioned upon acceptance of these
 *    clarifications.
 ******************************************************************************/

#include <qcc/platform.h>
#include <qcc/String.h>
#include <alljoyn/Status.h>

namespace qcc {

/**
 * KeyInfo
 */
class KeyInfo {

  public:

    /**
     * KeyInfo format
     */
    typedef enum {
        FORMAT_ALLJOYN = 0,   ///< AllJoyn format
        FORMAT_JWK = 1,   ///< JSON Web Key format
        FORMAT_X509 = 2,   ///< X.509 format
    } FormatType;

    /**
     * Key usage
     */
    typedef enum {
        USAGE_SIGNING = 0,   ///< key is used for signing
        USAGE_ENCRYPTION = 1   ///< key is used for encryption
    } KeyUsageType;

    /**
     * Default constructor.
     */
    KeyInfo(FormatType format) : format(format), keyIdLen(0), keyId(NULL)
    {
    }

    /**
     * Default destructor.
     */
    virtual ~KeyInfo()
    {
        delete [] keyId;
    }

    /**
     * Assign the key id
     * @param keyID the key id to copy
     * @param len the key len
     */
    void SetKeyId(const uint8_t* keyID, size_t len)
    {
        delete [] keyId;
        keyId = NULL;
        keyIdLen = 0;
        if (len == 0) {
            return;
        }
        keyId = new uint8_t[len];
        if (keyId == NULL) {
            return;
        }
        keyIdLen = len;
        memcpy(keyId, keyID, keyIdLen * sizeof(uint8_t));
    }

    /**
     * Retrieve the key ID.
     * @return  the key ID.  It's a pointer to an internal buffer. Its lifetime is the same as the object's lifetime.
     */
    const uint8_t* GetKeyId() const
    {
        return keyId;
    }

    /**
     * Retrieve the key ID length.
     * @return  the key ID length.
     */
    const size_t GetKeyIdLen() const
    {
        return keyIdLen;
    }

    /**
     * The required size of the exported byte array.
     * @return the required size of the exported byte array
     */

    const size_t GetExportSize();

    /**
     * Export the KeyInfo data to a byte array.
     * @param[in,out] buf the pointer to a byte array.  The caller must allocateenough memory based on call GetExportSize().
     * @return ER_OK for success; otherwise, an error code
     */

    QStatus Export(uint8_t* buf);

    /**
     * Import a byte array generated by a KeyInfo Export.
     * @param buf the export data
     * @param count the size of the export data
     * @return ER_OK for success; otherwise, an error code
     */

    QStatus Import(const uint8_t* buf, size_t count);

    /**
     * Get the format
     * @return the format
     */
    const FormatType GetFormat() const
    {
        return format;
    }

    /**
     * Comparison operators equality
     * @param[in] other right hand side KeyInfo
     * @return true is keys are equal.
     */
    bool operator==(const KeyInfo& other) const
    {
        if (format != other.format) {
            return false;
        }

        if (keyIdLen != other.keyIdLen) {
            return false;
        }

        if (keyId == NULL || other.keyId == NULL) {
            return keyId == other.keyId;
        }

        if (0 != memcmp(keyId, other.keyId, keyIdLen)) {
            return false;
        }

        return true;
    }

    /**
     * Comparison operators non-equality
     * @param[in] other right hand side KeyInfo
     * @return true is keys are not equal
     */
    bool operator!=(const KeyInfo& other) const
    {
        return !(*this == other);
    }

    /**
     * Assignment operator is private
     */
    KeyInfo& operator=(const KeyInfo& other) {
        if (this != &other) {
            format = other.format;
            keyIdLen = other.keyIdLen;
            delete [] keyId;
            keyId = new uint8_t[keyIdLen];
            memcpy(keyId, other.keyId, keyIdLen);
        }
        return *this;
    }

    /**
     * Copy constructor is private
     */
    KeyInfo(const KeyInfo& other) {
        format = other.format;
        keyIdLen = other.keyIdLen;
        keyId = new uint8_t[keyIdLen];
        memcpy(keyId, other.keyId, keyIdLen);
    }

  private:

    FormatType format;
    size_t keyIdLen;
    uint8_t* keyId;
};

} /* namespace qcc */


#endif
