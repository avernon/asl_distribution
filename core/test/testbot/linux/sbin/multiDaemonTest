#!/bin/bash

# Copyright AllSeen Alliance. All rights reserved.
#
# Contributed by Qualcomm Connected Experiences, Inc.,
# with authorization from the AllSeen Alliance, Inc.
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# 
# Pursuant to Section 1 of the License, the work of authorship constituting
# a Work and any Contribution incorporated in the Work shall mean only that
# Contributor's code submissions authored by that Contributor.  Any rights
# granted under the License are conditioned upon acceptance of these
# clarifications.

# Purpose:
#	Linux testbot main test script

# Return:
# 0 - Success
# 1 - Fail because two bundled daemons can't talk to each other
# 2 - Fail because bbservice can NOT launch
# 3 - Invalid command
# 4 - Can't create directory to store test result
# 5 - Thin client library path invalid

# Function name: usage
# Description: display command parameter
# Parameter: none
# Return: none
function usage() {
	echo 'Usage: multiDaemonTest -h -v -p [linux_sdk_path] -l [tc_sdk_path] -e [expect_script_path] -c [policydb_config_file_path] -x [events_actions_log_path]'
	echo '	-h help 
	-v verbose
	-p linux_sdk_path
	-l thin_client_sdk_path
	-e expect_script_path
	-c policydb routing node config file path
	-x events actions log path'
}

# Function name: parseCmdArgs
# Description: Parse command line arguments
# Parameter: none
# Return: 
#   3 - invalid command
function parseCmdArgs() {
    echo "Parsing arguments..."
    
    args=`getopt hvp:l:e:c:x: $*`

    if [ $? != 0 ]; then
        usage
        exit 3
    fi

    set -- $args

	#default is concise
    verbose=false

	# script name without path
	scriptName=`basename $0`

	# Default path for linux sdk-bin and sdk-rel subdirectories
	defPath=""

	# Default path for thin client linux sdk-bin and sdk-rel subdirectories
	thinPath=""

    # expect test script path
    expectPath=""
    
    # Policy db configuration xml root directory
	policydbXmlPath=""
		
    for i
    do
        case "$i" in
			-h) shift;usage;exit 0;;
            -v) shift;verbose=true; echo "verbose $verbose";;
			-p) shift;defPath=$1;echo "linux path $defPath";shift;;
			-l) shift;thinPath=$1;echo "thin client path $thinPath";shift;;
			-e) shift;expectPath=$1;echo "expect script path $expectPath";shift;;
			-c) shift;policydbXmlPath=$1;echo "Policydb xml path $policydbXmlPath";shift;;
			-x) shift;eaLogPath=$1;echo "Events Actions logs path $eaLogPath";shift;;
        esac
    done

	if [ -n "$defPath" -a -d "$defPath" ]; then
		linuxDir="$defPath"
		lastChr=${defPath#${defPath%?}}
		# Remove trailing /
		if [ "$lastChr" == "/" ]; then
			linuxDir=`echo "${defPath%?}"`
		fi
	else
		echo "Invalid path $defPath"
		exit 3
	fi
	
	if [ -n "$thinPath" -a -d "$thinPath" ]; then
		thinDir="$thinPath"
		lastChr=${thinPath#${thinPath%?}}
		# Remove trailing /
		if [ "$lastChr" == "/" ]; then
			thinDir=`echo "${thinPath%?}"`
		fi
	else
		echo "Invalid path $thinPath"
		exit 5
	fi

	# bbservice and bbclient should exist under $LinuxBinDir
	LinuxBinDir="${linuxDir}/sdk-rel/cpp/bin"
	# TrustedTLSampleRN located
	sampleBinDir="${linuxDir}/sdk-rel/cpp/bin/samples"

	# Debug bin for stress tests
	LinuxDbgBinDir="${linuxDir}/sdk-dbg/cpp/bin"
	LinuxDbgLibDir="${linuxDir}/sdk-dbg/cpp/lib"

	if [ -d "$LinuxBinDir" -a -d "$sampleBinDir" ]; then
		BBSERVICE="${LinuxBinDir}/bbservice"
		BBCLIENT="${LinuxBinDir}/bbclient"
		BBSIG="${LinuxBinDir}/bbsig"

		if [ -e "$BBSERVICE" -a -e "$BBCLIENT" -a -e "$BBSIG" ]; then
			$verbose && echo "bbservice and bbclient exist"
		else
			echo "bbservice or bbclient does NOT exist!"
			exit 3
		fi
		LinuxLibDir="${linuxDir}/sdk-rel/cpp/lib"
		if [ -f "$LinuxLibDir/liballjoyn.so" ]; then
			ls -ld "$LinuxLibDir/liballjoyn.so"
			export LD_LIBRARY_PATH="$LinuxLibDir${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}"
		else
			echo "warning, liballjoyn.so does NOT exist!"
		fi
	else
		echo "$LinuxBinDir or $sampleBinDir does NOT exist!"
		exit 3
	fi

	# Status.h for error code lookup
	LinuxHdrDir="${linuxDir}/sdk-rel/cpp/inc/alljoyn"
	ERRCODEAVAILABLE=0

	if [ -d "$LinuxHdrDir" ]; then
		STATUSHDR="${LinuxHdrDir}/Status.h"
		if [ -e "$STATUSHDR" ]; then
			echo "$STATUSHDR file available for error lookup"
			ERRCODEAVAILABLE=1
		fi
	fi

	# ajtcltest, aestest, mutter, svclite and clientlite should exist
	lightDir="${thinDir}/scons/core/ajtcl/dist/test"

	# libajtcl.so is required
	lightLibDir="${thinDir}/scons/core/ajtcl/dist/lib"

    LITE_READY=1
	if [ -d "$lightDir" -a -d "$lightLibDir" ]; then
		SVCLITE="${lightDir}/svclite"
		CLIENTLITE="${lightDir}/clientlite"

		if [ -e "$SVCLITE" -a -e "$CLIENTLITE" ]; then
			$verbose && echo "Both svclite and clientlite exist"
		else
			echo "svclite or clientlite does NOT exist!"
			LITE_READY=0
		fi
	else
		echo "$lightDir or $lightLibDir do NOT exist!"
		LITE_READY=0
	fi

	# about samples path
	aboutSampleDir="${linuxDir}/sdk-rel/cpp/bin/samples"

	# test tools release directory
	TOOLS_REL_DIR="${linuxDir}/test_tools-rel"
	TOOLS_DBG_DIR="${linuxDir}/test_tools-dbg"

    # ajtcsctest
    AJTCSCTEST_REL="${TOOLS_REL_DIR}/ajtcsctest"
    AJTCSCTEST_DBG="${TOOLS_DBG_DIR}/ajtcsctest"
    
	# NGNS unit test release binary
	NGNS_BIN_NAME="ajr2rtest"
	NGNS_REL_BIN="${TOOLS_REL_DIR}/${NGNS_BIN_NAME}"
	NGNS_DBG_BIN="${TOOLS_DBG_DIR}/${NGNS_BIN_NAME}"

	# slsemitter and slsreceiver binaries
	SLS_EMITTER_NAME="slsemitter"
	SLS_EMITTER_BIN="${TOOLS_REL_DIR}/${SLS_EMITTER_NAME}"

	SLS_RECEIVER_NAME="slsreceiver"
	SLS_RECEIVER_BIN="${TOOLS_REL_DIR}/${SLS_RECEIVER_NAME}"

	# C sample directory
	cRelSampleDir="${linuxDir}/sdk-rel/c/bin/samples"
	cDbgSampleDir="${linuxDir}/sdk-dbg/c/bin/samples"

	# policydb config xml directory
	if [ -n "$policydbXmlPath" -a -d "$policydbXmlPath" ]; then
	    POLICY_DB_ROOT="$policydbXmlPath"
		lastChr=${policydbXmlPath#${policydbXmlPath%?}}
		# Remove trailing /
		if [ "$lastChr" == "/" ]; then
			POLICY_DB_ROOT=`echo "${policydbXmlPath%?}"`
		fi
	else
		echo "Invalid policydb config xml path $policydbXmlPath"
	fi
	
	# policy db build directory
	POLICYDB_BUILD_DIR="${linuxDir}/../buildbot_pdb"
	POLICYDB_REL_BIN_DIR="${POLICYDB_BUILD_DIR}/sdk-rel/cpp/bin"
	POLICYDB_REL_LIB_DIR="${POLICYDB_BUILD_DIR}/sdk-rel/cpp/lib"
	POLICYDB_DBG_BIN_DIR="${POLICYDB_BUILD_DIR}/sdk-dbg/cpp/bin"
	POLICYDB_DBG_LIB_DIR="${POLICYDB_BUILD_DIR}/sdk-dbg/cpp/lib"

	POLICYDB_ABOUT_BIN_DIR="${POLICYDB_BUILD_DIR}/sdk-dbg/about/bin"
	POLICYDB_ABOUT_LIB_DIR="${POLICYDB_BUILD_DIR}/sdk-dbg/about/lib"

	POLICYDB_REL_TOOLS_DIR="${POLICYDB_BUILD_DIR}/test_tools-rel"
	POLICYDB_DBG_TOOLS_DIR="${POLICYDB_BUILD_DIR}/test_tools-dbg"
	
	if [ -n "$expectPath" -a -d "$expectPath" ]; then
		# New jenkins expect script path is passed in
	    expectScriptDir="$expectPath"
		lastChr=${expectPath#${expectPath%?}}
		# Remove trailing /
		if [ "$lastChr" == "/" ]; then
			expectScriptDir=`echo "${expectPath%?}"`
		fi
	else
	    # Old legacy expect script path
	    expectScriptDir="${linuxDir}/../../../sbin"
	fi 
	
	# Events and Actions log path
	if [ -n "$eaLogPath" -a -d "$eaLogPath" ]; then
	    EA_LOG_DIR="$eaLogPath"
		lastChr=${eaLogPath#${eaLogPath%?}}
		# Remove trailing /
		if [ "$lastChr" == "/" ]; then
			EA_LOG_DIR=`echo "${eaLogPath%?}"`
		fi
	else
		echo "Invalid events actions log path $eaLogPath"
	fi
}

# Function name: setResultDir
# Description: set result directory (./result/20120217102000) to hold output files 
# Parameter: none
# Return: 
#	exit 4 if result/detail directory can not be created
function setResultDir() {
	$verbose && echo "Set result directory..."

	local currentDir=`pwd`
	# local resultDir=${currentDir}"/result/"
	  local resultDir=$currentDir/

	# Final directory will be something like 20120217103120
	# local subDir=`date +%Y%m%d%H%M%S`
	# local detailsDir="detail/"
	  local subDir=.
	  local detailsDir=./

	if [ ! -d "$resultDir" ]; then
		mkdir $resultDir
	fi

	# Set directory to result and detail logs
	testResultDir=${resultDir}${subDir}"/"
	testDetailDir=${testResultDir}${detailsDir}

	if [ ! -d "$testResultDir" ]; then
		mkdir $testResultDir
	fi

	if [ ! -d "$testDetailDir" ]; then
		mkdir $testDetailDir
	fi	

	if [ ! -d "$testResultDir" ]; then
		echo "Can't create result directory $testResultDir, no permission or disk full?"
		exit 4
	elif [ ! -d "$testDetailDir" ]; then
		echo "Can't create log directory $testDetailDir, no permission or disk full?"
		exit 4
	fi

	# Test result file
    testResultFile="${testResultDir}${scriptName}_result.txt"
    testResultHtml="${testResultDir}${scriptName}_result.html"
    
	#detail analysis and intermediate files
	testDetailLog="${testDetailDir}${scriptName}_detail.txt"
	testErrorLog="${testDetailDir}${scriptName}_error.txt"

	#Debug variant path keyword
	debugVariant='dbg'
	
	# Core dump stdout file
	coreStdOut="coreDumpStdout.txt"
}
# Function name: SetUpGlobalVariables
# Description: setup global variables 
# Parameter: none
# Return: none
function SetUpGlobalVariables() {

	# Test type
	BUNDLED_TEST=0
	THIN_TEST=1
	STRESS_TEST=3
	POLICYDB_TEST=4
	PROFILE_TEST=5
	OTHER_TEST=2

	# Well known name to advertise and discover for bundled daemon test
	WELLNAME="gov.b"

	# name used by svclite
	THINNAME="org.alljoyn.svclite"

	BBCLIENTCOMPLETE="bbclient exiting with status 0 "
	# For example: bbclient exiting with status 36914 (0x9032)
	BBCLIENTFAIL="bbclient exiting with status [1-9][0-9]*"

	BBSIGCOMPLETE="bbsig exiting with 0 "
	# For example: bbsig exiting with 36914 (0x9032)
	BBSIGFAIL="bbsig exiting with [1-9][0-9]*"

	# Transports
	LOCAL="0x1"
	BT="0x2"
	TCP="0x4"
	ICE="0x20"

	daemonConfigFile="alljoyn_daemon.conf"
	clientliteLog="${testDetailDir}${scriptName}_clientlite.log"
	svcname="org.alljoyn.svclite"

	BBSIGPING="org.alljoyn.alljoyn_test::my_signal"
	BBSIGSENT="SendSignal:"
	CLIENTLITEPING1="org.alljoyn.alljoyn_test::my_ping"
	CLIENTLITEPING2="Get prop reply"
	SERVICEREPLY="Pinged with: Ping String"
	CLIENTLITERECV1="type REPLY sig=\"s\""
	CLIENTLITERECV2="Set prop reply"
	# siglite only send 10 signals
	SIGLITEPINGS=10
	# bbservice received signal
	SIGRECEIVED="RxSignal: /org/alljoyn/alljoyn_test"

	# About service log keywords
	BUSCONNECTED="BusAttachment connect succeeded."
	# Announcement keywords
	ABOUTADVERTISED="AboutObj Announce Succeeded"
	# JoinSession keywords
	SESSIONJOINED="Session Joined SessionId"
	# AboutService status code
    SERVICE_OK=0
    SERVICE_BUS_FAIL=1
    SERVICE_ANNOUNCE_FAIL=2
    SERVICE_ACCEPT_SESSION_FAIL=3
    SERVICE_EMPTY_LOG=5

	# About client log keywords
	ANNOUCEMENTREADY="Announce signal discovered"
	FROMBUS="From bus"
	# AboutClient status code
    CLIENT_OK=0
    CLIENT_BUS_FAIL=1
    CLIENT_MISS_ANNOUNCEMENT=2
    CLIENT_EMPTY_LOG=5

	# Thin client default daemon name
	svcliteOriginal="${lightDir}/svclite.c"
	svcliteOld="${lightDir}/svclite.old"
	svcliteUpdate="${lightDir}/svclite.update"

	tcDaemonName="org.alljoyn.BusNode"	
	newDaemonName="org.alljoyn.bd123"

	# How long takes thin client to connect to pre-installed daemon
	waitForConnection=10
	goodPwd="1234"
	errPwd="5794"

	# Authentication failed keyword
	AUTH_FAIL="Authentication[ ]\+failed"

	# Secure interface
	secureDef="#define SECURE_INTERFACE"
	
	# Policy db related path
	RECEIVESIGNAL="RxSignal:"
	NAME_DIR="nameowner"
	NAME_PREFIX_DIR="nameprefix"
	SEND_DEST_DIR="senddest"
	RECV_SENDER_DIR="recvsender"
	SEND_MEMBER_DIR="sendmember"
	RECV_MEMBER_DIR="recvmember"
	SLS_DIR="sls"
	SEND_ERROR_DIR="senderror"
	RECV_ERROR_DIR="recverror"
	SEND_TYPE_DIR="sendtype"
	RECV_TYPE_DIR="recvtype"
	ANY_ANNOUNCEMENT="AnnounceData"

	POLICY_SERVICE="${POLICYDB_DBG_TOOLS_DIR}/policyService"
	POLICY_CLIENTALL="${POLICYDB_DBG_TOOLS_DIR}/policyClientAll"
	POLICY_SERVICE_OK="policyService exiting with status 0"
	
	# Debug bin for profiling tests
	LinuxProfileBinDir="${linuxDir}/bin-dbg/cpp/bin"
	LinuxProfileLibDir="${linuxDir}/bin-dbg/cpp/lib"
	AjtestForProfile="${LinuxProfileBinDir}/ajtest"

	# Build type
	masterType=0
	branchType=1
	masterKey="master"
	branchKey="branch"
	buildType=$branchType
	
	# Commit id related
	SC_COMMIT_TYPE=1
	TC_COMMIT_TYPE=2
	TEST_COMMIT_TYPE=3
	SC_URL_PREFIX="https://git.allseenalliance.org/cgit/core/alljoyn.git/commit/?id="
	TC_URL_PREFIX="https://git.allseenalliance.org/cgit/core/ajtcl.git/commit/?id="
	TEST_URL_PREFIX="https://git.allseenalliance.org/cgit/core/test.git/commit/?id="
	UNKNOWN_ID="unknown"
	
	# event and action test programs
	EA_BIN_DIR="${TOOLS_REL_DIR}"
	EVENT_SERVICE_NAME="signal_service"
	EVENT_CLIENT_NAME="nameChange_client"
	REL_SIGNAL_SERVICE="${TOOLS_REL_DIR}/${EVENT_SERVICE_NAME}"
	REL_NAME_CHANGE_CLIENT="${TOOLS_REL_DIR}/${EVENT_CLIENT_NAME}"
	DBG_SIGNAL_SERVICE="${TOOLS_DBG_DIR}/${EVENT_SERVICE_NAME}"
	DBG_NAME_CHANGE_CLIENT="${TOOLS_DBG_DIR}/${EVENT_CLIENT_NAME}"
	
	eventLogHeader="Introspection XML in sample"
    eventLogTail="Error new name not given: nameChange_client"
}

# Function name: getCommitIds
# Description: 
#   Get commit ids from manifest.txt of sc sdk, tc sdk and test
# Parameter: none
# Return: 
#   scCommitId - commit ref id of SC SDK
#   tcCommitId   - commit ref id of TC SDK
#   testCommitId - commit ref id of core/test.git
function getCommitIds() {
	echo "Get commit ref ids from both SC SDK, TC SDK and test..." >> $testDetailLog
    
    scCommitId="${UNKNOWN_ID}"
    tcCommitId="${UNKNOWN_ID}"
    testCommitId="${UNKNOWN_ID}"
    
    local scManifest="${linuxDir}/sdk-rel/manifest.txt"
    local tcManifest="${thinDir}/scons/manifest.txt"
    local testManifest="${TOOLS_REL_DIR}/manifest.txt"
    
    local scCommit="unknown"
    local tclCommit="unknown"
    local testCommit="unknown"
    
	if [ -e "$scManifest" ]; then
	    scCommit=`grep -i "commit ref:" $scManifest | head -n 1 |awk -F " " '{print $NF}'`
	    if [ ! -z "$scCommit" ]; then
	        scCommitId=$scCommit
		    echo "SC core commit id is $scCommitId"
		else
		    echo "SC core commit id is unknown since manifest.txt does NOT have commit id information"
		fi
	fi
	
	if [ -e "$tcManifest" ]; then
	    tclCommit=`grep -i "commit ref:" $tcManifest | head -n 1 |awk -F " " '{print $NF}'`
	    if [ ! -z "$tclCommit" ]; then
	        tcCommitId=$tclCommit
		    echo "TC commit id is $tcCommitId"
		else
		    echo "TC commit id is unknown since manifest.txt does NOT have commit id information"
		fi
	fi
	
	if [ -e "$testManifest" ]; then
	    testCommit=`grep -i "test.git" $testManifest | head -n 1 |awk -F " " '{print $NF}'`
	    if [ ! -z "$testCommit" ]; then
	        testCommitId=$testCommit
		    echo "Core test commit id is $testCommitId"
		else
		    echo "Core test commit id is unknown since manifest.txt does NOT have commit id information"
		fi
	fi
}

# Function name: createCommitIdUrl
# Description: 
#   Create link url for commid id
# Parameter: 
#   commitType - SC or TC commit
#   commitId   - commit id
# Return: 
#   commitUrl is set to valid url or unknown
function createCommitIdUrl() {
	echo "Create commit id url from $commitId ..." >> $testDetailLog
	local commitType=$1
	local commitId=$2
	
	commitUrl="${UNKNOWN_ID}"
	
	if [ "$commitType" -eq "${SC_COMMIT_TYPE}" ]; then
	    commitUrl="${SC_URL_PREFIX}${commitId}"
	elif [ "$commitType" -eq "${TC_COMMIT_TYPE}" ]; then
	    commitUrl="${TC_URL_PREFIX}${commitId}"
	else
	    commitUrl="${TEST_URL_PREFIX}${commitId}"
	fi 
	
	echo "commit id url is $commitUrl"
	
}

# Function name: checkBuildType
# Description: 
#	check master or branch build (master branch has fix like #834-memory profiling)
# Parameter: 
#	buildPath - build path  
# Return: 
#   buildType is set to masterType or branchType
function checkBuildType() {
	local buildPath=$1
	$verbose && echo "Check if build path $buildPath is on master or branch..." >> $testDetailLog

	# Master build path should contains master
	if [[ $buildPath =~ $masterKey ]]; then
		$verbose && echo "Master build" >> $testDetailLog
		buildType=$masterType
	else
		$verbose && echo "Release branch build" >> $testDetailLog
		buildType=$branchType
	fi
}

# Function name: getPids
# Description: Get process ids with given name
# Parameter: 
#	1. processName - process name
# Return: 
#	pids has process ids
function getPids() {
	local processName=$1

	$verbose && echo "Checking $processName..."

	# find pids for processName	
	pids=`pidof "$processName"`

	$verbose && echo "$processName ids: $pids"
	
}

# Function name: killProcess
# Description: kill target process
# Parameter: 
#   1. processName - alljoyn-daemon, bbClient or bbService
# Return: 
#	none
function killProcess() {
    local processName=$1

    $verbose && echo "Stopping all $processName..."

	getPids $processName

    processCount=`echo $pids | wc -w`
        
    $verbose && echo " $processCount $processName exists"

    if [ "$processCount" -ge 1 ]; then 
        for pid in $pids; do
			$verbose && echo "kill $pid"
			kill -9 $pid > /dev/null  2>&1
        done   
    fi

}

# Function name: clean_up_all
# Description: Clean up lite process
# Parameter: none
# Return: 
#	none
function clean_up_all() {

	# Stop aestest
	killProcess "aestest"

	# Stop mutter
	killProcess "mutter"

	# Stop ajtcltest
	killProcess "ajtcltest"
	
	# Stop ajtest
	killProcess "ajtest"

	# C service
	echo "INFO: Stopping basic_c_service."
    killProcess "basic_c_service"

	# Make sure stop service and svclite before bbclient and clientlite 
	echo "INFO: Stopping bbservice."
    killProcess "bbservice"

	echo "INFO: Stopping policyService."
    killProcess "policyService"

    echo "INFO: Stopping svclite."
    killProcess "svclite"

	echo "INFO: Stopping bastress2."
    killProcess "bastress2"

	echo "INFO: Stopping basic_c_client."
    killProcess "basic_c_client"

	echo "INFO: Stopping bbclient."
    killProcess "bbclient"

	echo "INFO: Stopping policyClientAll."
    killProcess "policyClientAll"

	echo "INFO: Stopping clientlite."
    killProcess "clientlite"

	echo "INFO: Stopping bbsig."
    killProcess "bbsig"

	echo "INFO: Stopping siglite."
    killProcess "siglite"

    echo "INFO: Stopping daemon."
    killProcess "alljoyn-daemon"

	echo "INFO: Stopping bbjoin."
    killProcess "bbjoin"

	echo "INFO: Stopping TrustedTLSampleRN."
    killProcess "TrustedTLSampleRN"

	echo "INFO: Stopping ajr2rtest."
    killProcess "${NGNS_BIN_NAME}"
}

# Function name: cleanKeystore
# Description: Clean up keystore before security test
# Parameter: none
# Return: 
#	none
function cleanKeystore() {
    $verbose && echo "Remove keystore..." >> $testDetailLog
    
	# remove .alljoyn_keystore for SC
	rm -rf ${HOME}/.alljoyn_keystore >> $testDetailLog
	
	# remove ajtcl.nvram for TC keystore
	rm -rf ${testResultDir}ajtcl.nvram
}

# Function name: checkProcessCount
# Description: check process launched correctly
# Parameter: 
#   1. processName 	- bbClient or bbService
#   2. expectedCount- how many processes exist
# Return:
#	processCount is set to 0, 1 or actual process count
function checkProcessCount() {
    local processName=$1
	local expectedCount=$2

    $verbose && echo "checking $expectedCount $processName exists..." >> $testDetailLog

	processCount=$expectedCount
	getPids $processName

	local actualCount=`echo $pids | wc -w`
	
	if [ -z "$pids" ]; then
		$verbose && echo "$processName NOT running" >> $testDetailLog
		processCount=0
	elif [ "$actualCount" -ne "$expectedCount" ]; then
		$verbose && echo "$actualCount $processName running" >> $testDetailLog
		processCount=$actualCount
	else
		$verbose && echo "$processName running correctly" >> $testDetailLog
	fi
}

# Function name: launchProcess
# Description: Launch process on host
# Parameter: 
#   1. processName - binary name
#	2. wellKnownName-Well Known name for bbservice to broadcast
#   3. logName	   - log name
#	4. transport   - transport string: tcp, ice, local, any
#	5. daemonType  - 1 for thin client; 0 for bundled daemon; 3 for stress; 2 for others 
#	6. count       - how many signals(bbsig) or method calls(bbclient)
#	7. paras       - additional parameters for bastress2 and bbclient
# Return: 
#	none
function launchProcess() {
    local processName=$1
    local wkName=$2
	local logName=$3
	local transport=$4
	local daemonType=$5
	local count=$6
	local paras=$7

    $verbose && echo "Launching $processName..." >> $testDetailLog
	
	local arg1=""
	local arg2=""
	local arg3=""
	local arg=""

    if [ "$processName" == "bbservice" ]; then
		if [ "$transport" == "tcp" -o "$transport" == "Tcp" ]; then
			arg1="-t "
		elif [ "$transport" == "bt" -o "$transport" == "Bt" ]; then
			arg1="-b "
		elif [ "$transport" == "local" -o "$transport" == "Local" ]; then
			arg1="-l "
		else
			# ICE or ANY transport 
			arg1=""
		fi

		if [ -n "$wkName" ]; then
			$verbose && echo "bbservice well known name is $wkName"
	        arg2="-n $wkName -i 1 "

		fi
		arg=$arg1$arg2$paras
		$verbose && echo "bbservice option $arg"
    elif [ "$processName" == "bbclient" ]; then
		
		if [ -n "$wkName" ]; then
			arg1="-n ${wkName} "
		fi

		if [ "$count" -gt 1 ]; then	
			arg2="-c $count "
		fi

		arg=$arg1$arg2$paras
	elif [ "$processName" == "bbsig" ]; then
		if [ -n "$wkName" ]; then
			arg1="-n ${wkName} "
		fi

		if [ "$count" -gt 1 ]; then	
			arg2=" -c $count "
		fi

		arg=$arg1$arg2$paras
	elif [ "$processName" == "TrustedTLSampleRN" ]; then
		if [ -n "$wkName" ]; then
			arg="-n ${wkName} "
		fi
	elif [ "$processName" == "AboutService" -o "$processName" == "AboutClient" ]; then
		$verbose && echo "$processName has no arguments"
		arg=""
	else
		$verbose && echo "$processName has arguments $paras"
		arg="$paras"
	fi

	if [ "$daemonType" -eq "$BUNDLED_TEST" ]; then
		$verbose && echo "${LinuxBinDir}/${processName} $arg"
		if [ "$processName" == "bbservice" -o "$processName" == "bbclient" ]; then
			if [ "$transport" == "local" -o "$transport" == "Local" ]; then
				# local indicates a pre-installed daemon is running
				$verbose && echo "launch local bbclient..."
				stdbuf -i0 -o0 -e0 ${LinuxBinDir}/${processName} $arg > $logName 2>&1 &
			else
				# Launch with bundled daemon
				BUS_ADDRESS="null:" stdbuf -i0 -o0 -e0  ${LinuxBinDir}/${processName} $arg > $logName 2>&1 &
			fi
		elif [ "$processName" == "basic_c_service" -o "$processName" == "basic_c_client" ]; then
			if [ "$arg" == "debug" -o "$arg" == "DEBUG" ]; then
				${cDbgSampleDir}/${processName} 2>$logName 1>&2 &
			else
				# Release c sample
				${cRelSampleDir}/${processName} 2>$logName 1>&2 &
			fi
		elif [ "$processName" == "AboutService" -o "$processName" == "AboutClient" ]; then
			# Launch AboutService or AboutClient with bundled daemon
			stdbuf -i0 -o0 -e0 ${aboutSampleDir}/${processName} > $logName 2>&1 &
		elif [ "$processName" == "alljoyn-daemon" ]; then
			# launch pre-installed daemon with internal config
			${LinuxBinDir}/${processName} --internal > $logName 2>/dev/null &
		elif [ "$processName" == "TrustedTLSampleRN" ]; then
			${sampleBinDir}/TrustedTLSampleRN $arg > $logName 2>&1 &
			pid_of_trustedTLSampleRN=$!
		elif [ "$processName" == "${NGNS_BIN_NAME}" ]; then
			# Use timeout to prevent test hanging and wait forever
			timeout 20 ${TOOLS_REL_DIR}/${NGNS_BIN_NAME} > $logName 2>&1
			status_ngns=$?
		elif [ "$processName" == "${SLS_EMITTER_NAME}" -o "$processName" == "${SLS_RECEIVER_NAME}" ]; then
			# Use timeout to prevent test hanging and wait forever
			${TOOLS_REL_DIR}/${processName} $arg > $logName 2>&1 &
	    elif [ "$processName" == "${EVENT_SERVICE_NAME}" -o "$processName" == "${EVENT_CLIENT_NAME}" ]; then
			# running in background to prevent unexpected freeze
			stdbuf -o0 ${EA_BIN_DIR}/${processName} $arg > $logName &
		else
			# Launch bbsig with bundled daemon
			BUS_ADDRESS="null:" ${LinuxBinDir}/${processName} $arg > $logName 2>&1 &
		fi
	elif [ "$daemonType" -eq "$THIN_TEST" ]; then
		$verbose && echo "thin client ${LinuxBinDir}/${processName} $arg"
		# Thin client
		if [ "$processName" == "alljoyn-daemon" ]; then
			${LinuxBinDir}/alljoyn-daemon --config-file="$daemonConfigFile" --nofork --print-address --print-pid 1>$logName 2>&1 &
			pid_of_daemon=$!
		elif [ "$processName" == "bbjoin" ]; then
			# debug bbjoin use config.xml to serve as bundled daemon for thin clients
			${LinuxBinDir}/bbjoin 1>$logName 2>&1 &
			pid_of_bbjoin=$!
		elif [ "$processName" == "svclite" ]; then
			LD_LIBRARY_PATH=$lightLibDir stdbuf -i0 -o0 -e0 ${lightDir}/svclite $arg 1>$logName 2>&1 &
			pid_of_svclite=$!
		elif [ "$processName" == "bbservice" ]; then
			# bbservice printf buffer output file by default, stdbuf -o0 means output buffer is 0 
			BUS_ADDRESS="$daemon_unix_local_transport" stdbuf -i0 -o0 -e0 ${LinuxBinDir}/bbservice $arg 1>$logName 2>&1 &
		elif [ "$processName" == "clientlite" ]; then
			LD_LIBRARY_PATH=$lightLibDir ${lightDir}/clientlite $arg 1>$logName $arg 2>&1 &
			pid_of_clientlite=$!
		elif [ "$processName" == "siglite" ]; then
			# siglite may buffer output redirection
			LD_LIBRARY_PATH=$lightLibDir stdbuf -i0 -o0 -e0 ${lightDir}/siglite $arg 1>$logName 2>&1 &
			pid_of_siglite=$!
		elif [ "$processName" == "bbsig" ]; then
			BUS_ADDRESS="$daemon_unix_local_transport" ${LinuxBinDir}/bbsig $arg 1>$logName 2>&1 &
		elif [ "$processName" == "bbclient" ]; then
			BUS_ADDRESS="$daemon_unix_local_transport" ${LinuxBinDir}/bbclient $arg 1>$logName 2>&1 &
		elif [ "$processName" == "aestest" -o "$processName" == "mutter" ]; then
		    # aestest and mutter should complete within 40 seconds
			LD_LIBRARY_PATH=$lightLibDir timeout 40 ${lightDir}/${processName} > $logName 2>&1
			status_tc_test=$?
		elif [ "$processName" == "ajtcltest" ]; then
			LD_LIBRARY_PATH=$lightLibDir timeout 120 ${lightDir}/ajtcltest > $logName 2>&1
		elif [ "$processName" == "bastress2" ]; then
			LD_LIBRARY_PATH=$lightLibDir stdbuf -i0 -o0 -e0 ${lightDir}/bastress2 $paras 1>$logName 2>&1 &
			pid_of_bastress2=$!
		elif [ "$processName" == "ajtcsctest" ]; then
			# ajtcsctest is sc/tc interaction
			LD_LIBRARY_PATH=$lightLibDir timeout 720 ${AJTCSCTEST_REL} > $logName 2>&1
			tc_sc_status=$?
		else
			BUS_ADDRESS="null:" ${LinuxBinDir}/${processName} $arg > $logName 2>&1 &
		fi
	elif [ "$daemonType" -eq "$STRESS_TEST" ]; then
		$verbose && echo "Stress test ${LinuxDbgBinDir}/${processName} $arg"
		
		# Launch with bundled daemon
		LD_LIBRARY_PATH=$LinuxDbgLibDir ${LinuxDbgBinDir}/${processName} $arg > $logName 2>&1 &
	elif [ "$daemonType" -eq "$POLICYDB_TEST" ]; then
		$verbose && echo "Policy db ${LinuxDbgBinDir}/${processName} $arg"
		if [ "$processName" == "alljoyn-daemon" ]; then
			# launch pre-installed daemon with internal config
			LD_LIBRARY_PATH=${POLICYDB_DBG_LIB_DIR} ${POLICYDB_DBG_BIN_DIR}/${processName} --config-file=$wkName > $logName 2>/dev/null &
		elif [ "$processName" == "AboutService" -o "$processName" == "AboutClient" ]; then
			# Launch AboutService or AboutClient
			LD_LIBRARY_PATH=${POLICYDB_DBG_LIB_DIR} stdbuf -i0 -o0 -e0 ${POLICYDB_ABOUT_BIN_DIR}/${processName} > $logName 2>&1 &
		elif [ "$processName" == "policyService" -o "$processName" == "policyClientAll" ]; then
			# Launch PolicyService or PolicyClientAll
			LD_LIBRARY_PATH=${POLICYDB_DBG_LIB_DIR} stdbuf -i0 -o0 -e0 ${POLICYDB_DBG_TOOLS_DIR}/${processName} > $logName 2>&1 &
		else
			# Launch 
			LD_LIBRARY_PATH=${POLICYDB_DBG_LIB_DIR} stdbuf -i0 -o0 -e0 ${POLICYDB_DBG_BIN_DIR}/${processName} $arg > $logName 2>&1 &
		fi
	elif [ "$daemonType" -eq "$PROFILE_TEST" ]; then
		$verbose && echo "Profile test ${LinuxProfileBinDir}/${processName} $arg"
		
		# Launch with bundled daemon
		LD_LIBRARY_PATH=${LinuxProfileLibDir} valgrind --tool=memcheck --leak-check=yes ${LinuxProfileBinDir}/${processName} $arg > $logName 2>&1 &
		pid_of_profiling=$!
	else
		$verbose && echo "Any daemon ${LinuxBinDir}/${processName} $arg"
		# bbclient output buffer flush required
		if [ "$processName" == "bbclient" ]; then
			stdbuf -i0 -o0 -e0 ${LinuxBinDir}/bbclient $arg > $logName 2>&1 &
		else
			${LinuxBinDir}/${processName} $arg > $logName 2>&1 &
		fi
	fi
	
}

# Function name: findErrMsg
# Description: Find hex error code and matching message from log
# Parameter:
#	logName - bbclient/bbsig log
#	errPattern - bbclient/bbsig exiting with (status) [1-9][0-9]* (0xyyyy|ER_...)
# Return: 
#	hexErrCode will be set
#   errMsg will be set
function findErrMsg() {
	local logName=$1
	local errPattern=$2

	$verbose && echo "Find hex error code/msg from $logName ..." >> $testErrorLog
	hexErrCode=0x0000
	errMsg=""

	# Find hexErrCode: 0x9032 for bbclient exiting with status 36914 (0x9032)
	hexErrCode=`grep "$errPattern" $logName|awk -F "(" '{print $2}' |awk -F ")" '{print $1}'`

	$verbose && echo "Hex error code $hexErrCode" >> $testErrorLog

	# hexErrCode is the error message for debug binary
	echo $hexErrCode | grep "ER" >> $testErrorLog
	
	if [ $? -eq 0 ]; then
		$verbose && echo "debug binary $logName already has error message"
		errMsg=$hexErrCode
	elif [ "$hexErrCode" != "0x0000" -a "$hexErrCode" != "0x0" ]; then
		#find error message from Status.h
		if [ "$ERRCODEAVAILABLE" -eq 1 ]; then
			#get ER_BUS_REPLY_IS_ERROR_MESSAGE from "alljoyn/Status.h:    ER_BUS_REPLY_IS_ERROR_MESSAGE = 0x9032"
			errMsg=`grep $hexErrCode $STATUSHDR |awk -F "=" '{print $1}' |sed 's/^[ \t]*//'`
			$verbose && echo "Error msg $errMsg" >> $testErrorLog
		fi
	fi
}

# Function name: decideLogWithKeys
# Description: Check if last line of current test log include pass key
# Parameter:
#	logName
#	passKey
# Return: 
#	testResult will be set to 0 if pass; 6 if fail
#	errMsg will be set if testResult is 6
function decideLogWithKeys() {
	local logName=$1
	local passKey=$2
	
	local actualTimes=0

	$verbose && echo "Deciding test result in $logName with $passKey..." >> $testDetailLog

	testResult=6
	
	if [ -n "$logName" -a -n "$passKey" ]; then
		if [ -e "$logName" -a -s "$logName" ]; then
			actualTimes=`grep "$passKey" $logName|wc -l`

			if [ "$actualTimes" -eq 1 ]; then
				testResult=0
			else

				# Test fail
				echo "Test result=Fail"
			fi
		else
			echo "Empty or non-exist file $logName, test Fail!" >> $testDetailLog
			echo "Test result=Fail(client log empty)" >> $testErrorLog
		fi
	else
		echo "File $logName or key $passKey is null, test Fail!" >> $testDetailLog
		echo "Test result=Fail(key empty)" >> $testErrorLog
	fi
}
# Function name: logHasKeyAtLeastTimes
# Description: 
#   Check if log include key at least certain times
# Parameter:
#	logName
#	passKey
#   times
# Return: 
#	testResult will be set to 0 if pass; 6 if fail
#	errMsg will be set if testResult is 6
function logHasKeyAtLeastTimes() {
	local logName=$1
	local passKey=$2
	local times=$3
	
	local actualTimes=0

	$verbose && echo "Does $logName has $passKey at least $times ..." >> $testDetailLog

	testResult=6
	
	if [ -n "$logName" -a -n "$passKey" ]; then
		if [ -e "$logName" -a -s "$logName" ]; then
			actualTimes=`grep "$passKey" $logName|wc -l`

			if [ "$actualTimes" -ge "$times" ]; then
				testResult=0
			else

				# Test fail
				echo "Test result=Fail"
			fi
		else
			echo "Empty or non-exist file $logName, test Fail!" >> $testDetailLog
			echo "Test result=Fail(client log empty)" >> $testErrorLog
		fi
	else
		echo "File $logName or key $passKey is null, test Fail!" >> $testDetailLog
		echo "Test result=Fail(key empty)" >> $testErrorLog
	fi
}
# Function name: decideUnitTest
# Description: 
#	unit test log should include specified keywords
# Parameter:
#	logName  - log file name
#	passKeys - keywords in successful log
# Return: 
#	testResult will be set to 0 if pass; 6 if fail
function decideUnitTest() {
	local logName=$1
	local passKeys=$2

	local actualTimes=0

	$verbose && echo "Deciding unit test result in $logName with $passKey..." >> $testDetailLog

	testResult=6

	if [ -e "$logName" -a -s "$logName" ]; then
		utPass=`egrep "$passKeys" $logName`
			
		if [ -n "$utPass" ]; then
			echo "$logName has $passKeys " >> $testDetailLog
			testResult=0
		else
			echo "Test Fail($passKeys miss from output)"
			echo "$passKeys not exist in output file, unit test fail!"  >> $testErrorLog
		fi
	else
		echo "Test Fail(log file empty)"
		echo "Log file empty"  >> $testErrorLog
	fi
}

# Function name: twoDaemonsTest
# Description: run two bundled daemons test
# Parameter:
#	transport - tcp, any or ice
# Return: 
#	testResult is 0 if pass; 6 fail
function twoDaemonsTest() {
	local transport=$1

	$verbose && echo "Two bundled daemons over $transport test..." >> $testDetailLog

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))
	
	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase(method call $transport)"
	echo "Test case=$testCase(method call $transport)">> $testResultFile
    echo "<p>Test case=$testCase(method call $transport)<p>">> $testResultHtml
    
	local serviceLog="${testDetailDir}${scriptName}_${testCase}_bbservice.log"
	local clientLog="${testDetailDir}${scriptName}_${testCase}_bbclient.log"
	local name="${WELLNAME}${testCase}"
	
	local serviceError="${testDetailDir}${scriptName}_${testCase}_bbservice_error.txt"
	local clientError="${testDetailDir}${scriptName}_${testCase}_bbclient_error.txt"

	# Stop existing pre-installed daemon, bbservice and bbclient running
	killProcess "alljoyn-daemon"

	killProcess "bbservice"

	killProcess "bbclient"

	# Launch bbservice with BUS_ADDRESS=""
	launchProcess "bbservice" $name $serviceLog $transport 0 1 ""

	# Make sure bbservice is launched
	sleep 5

	# Confirm only one process is launched
	checkProcessCount "bbservice" 1	

	if [ "$processCount" -ne 1 ]; then
	    mv $serviceLog $serviceError
		echo "bbservice launch failure" >> $testErrorLog
		testResults[totalTests]=6
		echo "Test result=Fail(bbservice crash)" >> $testResultFile
		echo "<p>Test result=Fail(bbservice <a class="error" href="\"$serviceError\"">crash</a>)</p>" >> $testResultHtml
	else
		# Launch bbclient with BUS_ADDRESS=""
		launchProcess "bbclient" $name $clientLog $transport 0 100 "-d"

		# Make sure discovery, joinSession, method call complete
		sleep 120

		# Check bbclient log to decide Pass/Fail
		decideLogWithKeys $clientLog "$BBCLIENTCOMPLETE"

		if [ "$testResult" -eq 0 ]; then
			testResults[totalTests]=0
			echo "Test result=Pass" >> $testResultFile
			echo "<p>Test result=Pass</p>" >> $testResultHtml
		else
		    mv $clientLog $clientError
		    
			# Find error message from code
			findErrMsg $clientLog "$BBCLIENTFAIL"
 
			testResults[totalTests]=6
			echo "Test result=Fail($errMsg)" >> $testResultFile
			echo "<p>Test result=Fail(<a class="error" href="\"$clientError\"">$errMsg</a>)</p>" >> $testResultHtml
		fi
	fi

	# Cleanup
	killProcess "bbservice"

	killProcess "bbclient"

	sleep 2

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: ngnsTest
# Description: run ngns unit test
# Parameter: none
# Return: 
#	testResult is 0 if pass; 6 fail
function ngnsTest() {
	$verbose && echo "NGNS unit test..." >> $testDetailLog

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))
	
	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase(NGNS unit test)"
	echo "Test case=$testCase(NGNS unit test)">> $testResultFile
    echo "<p>Test case=$testCase(NGNS unit test)</p>">> $testResultHtml
    
	local daemonLog="${testDetailDir}${scriptName}_daemon_ngns.log"
	local ngnsLog="${testDetailDir}${scriptName}_ngns.log"

	local daemonError="${testDetailDir}${scriptName}_daemon_ngns_error.txt"
	local ngnsError="${testDetailDir}${scriptName}_ngns_error.txt"
		
	# Stop everything
	clean_up_all

	# Start routing node
	launchProcess "alljoyn-daemon" "" $daemonLog "" 0 1 ""

	sleep 1

	# Start ngns test
	launchProcess "${NGNS_BIN_NAME}" "" $ngnsLog "" 0 1 ""
	echo "Exit status of ${NGNS_BIN_NAME} is ${status_ngns}"

	# Confirm alljoyn-daemon still alive
	checkProcessCount "alljoyn-daemon" 1	
	local daemonLive=$processCount
	
	if [ "${status_ngns}" -eq 0 -a "$daemonLive" -eq 1 ]; then
		testResults[totalTests]=0
		echo "Test result=Pass" >> $testResultFile
		echo "<p>Test result=Pass</p>" >> $testResultHtml
	elif [ "${status_ngns}" -ne 0 ]; then
	    mv $ngnsLog $ngnsError
		testResults[totalTests]=6
		echo "Test result=Fail(exit non-zero, check $ngnsLog)" >> $testResultFile
		echo "<p>Test result=Fail(exit non-zero, check <a class="error" href="\"$ngnsError\"">log</a>)</p>" >> $testResultHtml
	else
		testResults[totalTests]=6
		echo "Test result=Fail(daemon crash)" >> $testResultFile
		echo "<p>Test result=Fail(daemon crash)</p>" >> $testResultHtml
	fi

	# Cleanup
	killProcess "alljoyn-daemon"

	sleep 1

	# Increse test count
	totalTests=$(($totalTests + 1))	

}

# Function name: rawSocketTest
# Description: run rawservice/rawclient test
# Parameter:
#	transport - tcp, any or ice
# Return: 
#	testResult is 0 if pass; 6 fail
function rawSocketTest() {
	local transport=$1

	$verbose && echo "rawservice/rawclient over $transport test..." >> $testDetailLog

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))
	
	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase(Linux rawsocket over $transport)"
	echo "Test case=$testCase(Linux rawsocket over $transport)">> $testResultFile
	echo "<p>Test case=$testCase(Linux rawsocket over $transport)</p>">> $testResultHtml

	local serviceLog="${testDetailDir}${scriptName}_${testCase}_rawservice.txt"
	local clientLog="${testDetailDir}${scriptName}_${testCase}_rawclient.txt"
	
	# Stop existing pre-installed daemon, rawservice and rawclient running
	killProcess "alljoyn-daemon"

	killProcess "rawservice"

	killProcess "rawclient"

	# Launch rawservice with BUS_ADDRESS="null:"
	launchProcess "rawservice" "" $serviceLog $transport 0 1 ""

	# Make sure bbservice is launched
	sleep 5

	# Confirm only one process is launched
	checkProcessCount "rawservice" 1	

	if [ "$processCount" -ne 1 ]; then
		echo "rawservice launch failure" >> $testErrorLog
		testResults[totalTests]=6
		echo "Test result=Fail(rawservice crash)" >> $testResultFile
		echo "<p>Test result=Fail(rawservice crash)</p>" >> $testResultHtml
	else
		# Launch rawclient with BUS_ADDRESS=""
		launchProcess "rawclient" "" $clientLog $transport 0 1 ""

		# Make sure discovery, joinSession, method call complete
		sleep 60

		local DISCOVERY_KEY="FoundAdvertisedName(name=org.alljoyn.raw_test"
		# Discovery can happen on UDP, TCP or both
		logHasKeyAtLeastTimes $clientLog "${DISCOVERY_KEY}" 1
		local discoveryOk=$testResult

		local SESSION_KEY="Session Joined with session id"
		decideLogWithKeys $clientLog "${SESSION_KEY}"
		local joinOk=$testResult

		local READ_KEY="Bytes: abcdefghijklmnopqrstuvwxyz"
		decideLogWithKeys $clientLog "${READ_KEY}"
		local readOk=$testResult

		local EXIT_KEY="rawclient exiting with status 0x0 "
		# Check bbclient log to decide Pass/Fail
		decideLogWithKeys $clientLog "${EXIT_KEY}"
		local exitOk=$testResult

		if [ "$discoveryOk" -eq 0 -a "$joinOk" -eq 0 -a "$readOk" -eq 0 -a "$exitOk" -eq 0 ]; then
			testResults[totalTests]=0
			echo "Test result=Pass" >> $testResultFile
			echo "<p>Test result=Pass</p>" >> $testResultHtml
		else
		    local clientError="${testDetailDir}${scriptName}_${testCase}_rawclient_error.txt"
	        mv $clientLog $clientError
	        
		    if [ "$discoveryOk" -ne 0 ]; then        
			    testResults[totalTests]=6
			    echo "Test result=Fail(discovery)" >> $testResultFile
			    echo "<p>Test result=Fail(<a class="error" href="\"$clientError\"">discovery</a>)</p>" >> $testResultHtml
		    elif [ "$joinOk" -ne 0 ]; then
			    testResults[totalTests]=6
			    echo "Test result=Fail(joinSession)" >> $testResultFile
			    echo "<p>Test result=Fail(<a class="error" href="\"$clientError\"">joinSession</a>)</p>" >> $testResultHtml
		    elif [ "$readOk" -ne 0 ]; then
			    testResults[totalTests]=6
			    echo "Test result=Fail(read)" >> $testResultFile
			    echo "<p>Test result=Fail(<a class="error" href="\"$clientLog\"">read</a>)</p>" >> $testResultHtml
		    else
    			testResults[totalTests]=6
	    		echo "Test result=Fail(exit non-zero)" >> $testResultFile
	    		echo "<p>Test result=Fail(<a class="error" href="\"$clientError\"">exit non-zero)</p>" >> $testResultHtml
	    	fi
		fi
	fi

	# Cleanup
	killProcess "rawservice"

	killProcess "rawclient"

	sleep 2

	# Increse test count
	totalTests=$(($totalTests + 1))	
}
# Function name: aesTest
# Description: aestest
# Parameter: none
# Return: none
function aesTest() {	

	$verbose && echo "Run aestest..." >> $testDetailLog

	# Initialize result to fail
	testResults[totalTests]=6

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase(TCLCTP-32 aestest)"
	echo "Test case=$testCase(TCLCTP-32 aestest)">> $testResultFile
	echo "<p>Test case=$testCase(TCLCTP-32 aestest)</p>">> $testResultHtml

	local aestestLog="${testDetailDir}${scriptName}_${testCase}_aestest.log"

	# Stop existing pre-installed daemon, bbservice and bbclient running
	clean_up_all

	# Launch aestest in thin mode
	launchProcess "aestest" "" $aestestLog "tcp" 1 1 ""
    echo "Exit code of aestest is ${status_tc_test}"
	
	if [ "${status_tc_test}" -eq 0 ]; then
		testResults[totalTests]=0
		echo "Test result=Pass" >> $testResultFile
		echo "<p>Test result=Pass</p>" >> $testResultHtml
	elif [ "${status_tc_test}" -eq 124 ]; then
	    # 124 means timeout
	    local aestestError="${testDetailDir}${scriptName}_${testCase}_aestest_error.txt"
	    mv $aestestLog $aestestError
	    testResults[totalTests]=6
		echo "Test result=Fail(hangs)" >> $testResultFile
		echo "Test result=Fail(<a class="error" href="\"$aestestError\"">hangs</a>)" >> $testResultHtml
	else
	    local aestestError="${testDetailDir}${scriptName}_${testCase}_aestest_error.txt"
	    mv $aestestLog $aestestError
	    testResults[totalTests]=6
		echo "Test result=Fail(other)" >> $testResultFile
		echo "<p>Test result=Fail(<a class="error" href="\"$aestestError\"">other</a>)</p>" >> $testResultHtml
	fi
	
	# Stop existing pre-installed daemon, bbservice and bbclient running
	clean_up_all

	sleep 2

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: mutter
# Description: mutter
# Parameter: none
# Return: none
function mutter() {	

	$verbose && echo "Run mutter..." >> $testDetailLog

	# Initialize result to fail
	testResults[totalTests]=6

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase(TCLCTP-31 mutter)"
	echo "Test case=$testCase(TCLCTP-31 mutter)">> $testResultFile
    echo "<p>Test case=$testCase(TCLCTP-31 mutter)</p>">> $testResultHtml
    
	local mutterLog="${testDetailDir}${scriptName}_${testCase}_mutter.log"

	# Stop existing pre-installed daemon, bbservice and bbclient running
	clean_up_all

	# Launch mutter in thin mode
	launchProcess "mutter" "" $mutterLog "tcp" 1 1 ""
    echo "Exit code of mutter is ${status_tc_test}"
	
	if [ "${status_tc_test}" -eq 0 ]; then
		testResults[totalTests]=0
		echo "Test result=Pass" >> $testResultFile
		echo "<p>Test result=Pass</p>" >> $testResultHtml
	elif [ "${status_tc_test}" -eq 124 ]; then
	    local mutterError="${testDetailDir}${scriptName}_${testCase}_mutter_error.txt"
	    mv $mutterLog $mutterError
	    testResults[totalTests]=6
		echo "Test result=Fail(hangs)" >> $testResultFile
		echo "Test result=Fail(<a class="error" href="\"$mutterError\"">hangs</a>)" >> $testResultHtml
	else
		local mutterError="${testDetailDir}${scriptName}_${testCase}_mutter_error.txt"
	    mv $mutterLog $mutterError
	    testResults[totalTests]=6
		echo "Test result=Fail(other)" >> $testResultFile
		echo "Test result=Fail(<a class="error" href="\"$mutterError\"">other</a>)" >> $testResultHtml
	fi

	# Stop existing pre-installed daemon, bbservice and bbclient running
	clean_up_all

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: ajtcltest
# Description: ajtcltest
# Parameter: none
# Return: none
function ajtcltest() {	

	$verbose && echo "Run ajtcltest..." >> $testDetailLog

	# Initialize result to fail
	testResults[totalTests]=6

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase(ajtcltest)"
	echo "Test case=$testCase(ajtcltest)">> $testResultFile
	echo "<p>Test case=$testCase(ajtcltest)</p>">> $testResultHtml

	local ajtcltestLog="${testDetailDir}${scriptName}_${testCase}_ajtcltest.log"

	# Stop everything
	clean_up_all
	
	# Clean keystore
    cleanKeystore
    
	local bbserviceLog="bbservice_ajtcltest.log"
	
	# Launch bbservice for Security test    
    launchProcess "bbservice" "org.alljoyn.svclite" $bbserviceLog "" 0 1 ""
    
    sleep 1
	
	checkProcessCount "bbservice" 1
	local serviceLive=$processCount
	
	if [ "$serviceLive" -eq 1 ]; then
		# Launch ajtcltest
		launchProcess "ajtcltest" "" $ajtcltestLog "" 1 1 ""
	
		# Check ajtcltest log
		if [ -e "$ajtcltestLog" -a -s "$ajtcltestLog" ]; then
		
			local passKey="ajtcltest exiting with status 0 "
			echo "ajtcltest pass key is $passKey"

			decideUnitTest $ajtcltestLog "$passKey"

			if [ "$testResult" -eq 0 ]; then
				testResults[totalTests]=0
				echo "Test result=Pass" >> $testResultFile
				echo "<p>Test result=Pass</p>" >> $testResultHtml
			else
			    local ajtcltestError="${testDetailDir}${scriptName}_${testCase}_ajtcltest_error.txt"
			    mv $ajtcltestLog $ajtcltestError
				testResults[totalTests]=6
				echo "Test result=Fail" >> $testResultFile
				echo "<p>Test result=<a class="error" href="\"$ajtcltestError\"">Fail</a></p>" >> $testResultHtml
			fi
		else
		    testResults[totalTests]=5
			echo "Test result=Block(miss log file)" >> $testResultFile
			echo "<p>Test result=Block(miss log file)</p>" >> $testResultHtml
		fi
	else
	    local bbserviceError="bbservice_ajtcltest_error.txt"
        mv $bbserviceLog $bbserviceError
		echo "Test result=Block(service launch fail)" >> $testResultFile
		echo "<p>Test result=Block(<a class="error" href="\"$bbserviceError\"">service launch fail</a></p>" >> $testResultHtml
		testResults[totalTests]=5
	fi

	# Stop ajtcltest
	clean_up_all

    # Clean keystore
    cleanKeystore
    
	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: createDaemonConfig
# Description: create daemon config file
# Parameter: 
#	maxUntrustedClients - max untrusted clients count
#	advertisedName - advertised daemon name for thin client
# Return: none
function createDaemonConfig() {
	local maxUntrustedClients=$1
	local advertisedName=$2

	mv $daemonConfigFile ${daemonConfigFile}_${daemon_standard_port_number} >/dev/null 2>&1

	# Generate a random dynamic port number
	daemon_standard_port_number=$(( 49152 + ($(head -c 1 /dev/urandom| od -t u | head --lines=1 | awk '{print $2}') % 64) * 255 + $(head -c 1 /dev/urandom| od -t u | head --lines=1 | awk '{print $2}')))

	daemon_unix_local_transport="unix:abstract=alljoyn-$daemon_standard_port_number"

	echo "Random port: $daemon_standard_port_number"
	echo "Local transport string: $daemon_unix_local_transport"

	# Generate the appropriate config file.
	# Note: Unfortunately, there is no easy way to get an up-to-date config file
	#       from anywhere. The config files in the source tree are either out-dated
	#       or have the necessary lines commented out. So, we resort to generating
	#       our own config file.
	#       Also, we try to generate as restricted configuration as possible.
	#       This is because the daemon is NOT under test.
	config_file_string="<!DOCTYPE busconfig PUBLIC \"-//freedesktop//DTD D-Bus Bus Configuration 1.0//EN\"
 \"http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd\">
<busconfig>
  <!-- Our well-known bus type, do not change this -->
  <type>alljoyn</type>
  <listen>$daemon_unix_local_transport</listen>
  <listen>tcp:iface=*,port=$daemon_standard_port_number</listen>
  <flag name=\"ns_enable_v1\">true</flag>
  <limit name=\"auth_timeout\">32768</limit>
  <limit name=\"max_incomplete_connections\">16</limit>
  <limit name=\"max_completed_connections\">64</limit>

  <flag name=\"restrict_untrusted_clients\">true</flag>
  <limit name=\"max_untrusted_clients\">$maxUntrustedClients</limit>

  <property name=\"router_advertisement_prefix\">$advertisedName.</property>

</busconfig>
"
	printf "$config_file_string" > $daemonConfigFile

}

# Function name: svcLiteIntroTest
# Description: run svclite, bbclient introspection test
# Parameter: none
# Return: 
#	testResult is 0 if pass; 6 fail
function svcLiteIntroTest() {
	$verbose && echo "TCLTCP-33 svclite/bbclient on local bus..." >> $testDetailLog

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))
	# is svclite connected to daemon: 0-yes, 1-no
	local svcLiteConnected=0

	# Leave an empty line between tests in report
	echo >> $testResultFile
	echo "Test case=$testCase(TCLTCP-33 svclite/bbclient on local bus)"
	echo "Test case=$testCase(TCLTCP-33 svclite/bbclient on local bus)">> $testResultFile

    echo "<br>" >> $testResultHtml
    echo "<p>Test case=$testCase(TCLTCP-33 svclite/bbclient on local bus)</p>">> $testResultHtml
    
	# Stop old daemon
	clean_up_all

    # Clean keystore
    cleanKeystore
    
	local daemonLog="daemon_svclite.log"
	
	# Launch standard daemon for svclite to connect to 
	launchProcess "alljoyn-daemon" "" $daemonLog "tcp" 1 1 ""

	# The following paramter of three seconds is NEEDED as a work around
	# for svclite to connect to the daemon.
	sleep 3

	local svcliteIntroLog="svclite_introspection.log"

	# Start svclite
	# Note: The order of starting alljoyn-daemon first and then starting svclite
	#       is important. The chances of successful discovery are higher now.
	launchProcess "svclite" $svcname $svcliteIntroLog "tcp" 1 1 ""
	
	echo "INFO: alljoyn-daemon started (pid $pid_of_daemon). Writing output to alljoyn-daemon.log."
	echo "INFO: svclite started (pid $pid_of_svclite). Writing output to svclite.log."
	
	# Wait some time for thin client to connect to pre-installed daemon
	sleep $waitForConnection

	# Perform a check that svclite was able to open a connection
	# to the port on which daemon is listening on.
	if ! lsof -i -n -P | grep $pid_of_svclite | grep -q $daemon_standard_port_number
	then
   	 	echo "ERROR: svclite was unable to connect to daemon. Cannot continue." >> $testErrorLog
    	svcLiteConnected=1
	fi
	
	if [ "$svcLiteConnected" -eq 0 ]; then
	
		#launchProcess "bbsig" $svcname $bbsigLog "tcp" 1 ""
		echo "Linux binary dir $LinuxBinDir"
		echo "$daemon_unix_local_transport"

		local clientLog="${testDetailDir}${scriptName}_bbclient_introspect.log"

		sleep 1

		# Run bbclient so svclite printf buffer is flushed
		launchProcess "bbclient" $svcname $clientLog "tcp" 1 100 "-i -e ECDHE_PSK"
		#BUS_ADDRESS="$daemon_unix_local_transport" "${LinuxBinDir}/bbclient" -i -n $svcname -c 100
	
		# Sleep 70 seconds to make sure bbclient complete
		sleep 70

		# make sure alljoyn-daemon, bbservice and clientlite are still running
		checkProcessCount "alljoyn-daemon" 1
		local daemonCount=$processCount

		checkProcessCount "svclite" 1
		local svcliteCount=$processCount

		# Stop all processes
		clean_up_all
		
		# daemon and svclite should still run
		if [ "$daemonCount" -gt 0 -a "$svcliteCount" -gt 0 ]; then
			# Check bbclient log to make sure they are complete
			decideLogWithKeys $clientLog "$BBCLIENTCOMPLETE"

			# bbclient should exit with 0
			if [ "$testResult" -eq 0 ]; then		
				testResults[totalTests]=0
				echo "Test result=Pass" >> $testResultFile
				echo "<p>Test result=Pass</p>" >> $testResultHtml
			else
				# Find error message from code
				findErrMsg $clientLog "$BBCLIENTFAIL"
				
                local clientError="${testDetailDir}${scriptName}_bbclient_introspect_error.txt"
                mv $clientLog $clientError
				echo "Test failed as bbclient fail $errMsg" >> $testErrorLog
				testResults[totalTests]=6
				echo "Test result=Fail(bbclient fail $errMsg)" >> $testResultFile
				echo "<p>Test result=Fail(<a class="error" href="\"$bbclient\""> fail $errMsg</a>)</p>" >> $testResultHtml
			fi
		elif [ "$daemonCount" -eq 0 ]; then
			echo "daemon crash!" >> $testErrorLog
			testResults[totalTests]=6
			echo "Test result=Fail(daemon crash!)" >> $testResultFile
			echo "<p>Test result=Fail(daemon crash!)</p>" >> $testResultHtml
		else
			echo "svclite crash!" >> $testErrorLog
			testResults[totalTests]=6
			echo "Test result=Fail(svclite crash!)" >> $testResultFile
			echo "<p>Test result=Fail(svclite crash!)</p>" >> $testResultHtml
		fi
	else
		# Stop all processes
		clean_up_all

		testResults[totalTests]=6
		echo "Test result=Fail(svclite connect to daemon fail!)" >> $testResultFile
	fi

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: clientLiteTest
# Description: run clientlite, bbservice test
# Parameter: none
# Return: 
#	testResult is 0 if pass; 6 fail
function clientLiteTest() {
	$verbose && echo "clientlite, bbservice test..." >> $testDetailLog

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))
	# is clientlite connected to daemon: 0-yes, 1-no
	local clientLiteConnected=0

	# Leave an empty line between tests in report
	echo >> $testResultFile

	echo "Test case=$testCase(clientlite/bbservice)"
	echo "Test case=$testCase(clientlite/bbservice)">> $testResultFile

	# Stop old daemon
	clean_up_all

	local daemonLog="daemon_clientlite.log"
	# Launch standard daemon for svclite to connect to 
	launchProcess "alljoyn-daemon" "" $daemonLog "tcp" 1 1 ""

	# The following paramter of three seconds is NEEDED as a work around
	# for clientlite to connect to the daemon.
	sleep 3

	local clientliteLog="clientlite.log"
	# Start clientlite
	# Note: The order of starting alljoyn-daemon first and then starting clientlite
	#       is important. The chances of successful discovery are higher now.
	launchProcess "clientlite" $svcname $clientliteLog "tcp" 1 1 ""

	# Wait some time for thin client to connect to pre-installed daemon
	sleep $waitForConnection

	echo "INFO: alljoyn-daemon started (pid $pid_of_daemon). Writing output to alljoyn-daemon.log."
	echo "INFO: svclite started (pid $pid_of_clientlite). Writing output to clientlite.log."
	
	# Perform a check that svclite was able to open a connection
	# to the port on which daemon is listening on.
	if ! lsof -i -n -P | grep $pid_of_clientlite | grep -q $daemon_standard_port_number
	then
   	 	echo "ERROR: clientlite was unable to connect to daemon. Cannot continue." >> $testErrorLog
    	clientLiteConnected=1
	fi
	
	if [ "$clientLiteConnected" -eq 0 ]; then
		local bbserviceLog="${testDetailDir}${scriptName}_lite_bbservice.log"

		#launchProcess "bbsig" $svcname $bbsigLog "tcp" 1
		echo "Linux binary dir $LinuxBinDir"
		echo "$daemon_unix_local_transport"

		#bbservice launched in thin mode
		launchProcess "bbservice" $svcname $bbserviceLog "local" 1 0 ""
		#BUS_ADDRESS="$daemon_unix_local_transport" ${LinuxBinDir}/bbservice -n $svcname
	
		# Sleep 60 seconds so some Ping are exchanged between bbservice and clientlite
		sleep 60

		# make sure alljoyn-daemon, bbservice and clientlite are still running
		checkProcessCount "alljoyn-daemon" 1
		local daemonCount=$processCount

		checkProcessCount "bbservice" 1
		local bbserviceCount=$processCount

		checkProcessCount "clientlite" 1
		local clientliteCount=$processCount

		# Stop all processes
		clean_up_all

		if [ "$daemonCount" -gt 0 -a "$bbserviceCount" -gt 0 -a "$clientliteCount" -gt 0 ]; then

			# Check client sent and received pings, 1st receive is NOT from sent 
			local clientSent=$(egrep -c "$CLIENTLITEPING1|$CLIENTLITEPING2" $clientliteLog)
			local servicePings=$(grep -c "$SERVICEREPLY" $bbserviceLog)
			local clientReceived=$(egrep -c "$CLIENTLITERECV1|$CLIENTLITERECV2" $clientliteLog)

			echo "clientlite sent $clientSent pings"
			echo "bbservice replied $servicePings times"
			echo "clientlite received $clientReceived times"

			# bbservice should send at least 1 ping reply
			# clientlite may not redirect AJ_Printf to output log consistently 
			if [ "$servicePings" -gt 0 ]; then		
				# 1st receive is not from my_ping interface, so receive may 
				local pingReceived=$(($clientReceived - 1))	
			
				# client may sent 1 ping more or less than service replied due to timing 
				local pingsMinus=$(($clientSent - 1))
				local pingsPlus=$(($clientSent + 1))

				testResults[totalTests]=0
				echo "Test result=Pass" >> $testResultFile		
				
			else
				echo "Test failed as bbservice 0 ping reply!" >> $testErrorLog
				testResults[totalTests]=6
				echo "Test result=Fail(bbservice 0 ping reply)" >> $testResultFile
			fi
		elif [ "$daemonCount" -eq 0 ]; then
			echo "daemon crash!" >> $testErrorLog
			testResults[totalTests]=6
			echo "Test result=Fail(daemon crash!)" >> $testResultFile
		elif [ "$bbserviceCount" -eq 0 ]; then
			echo "bbservice crash!" >> $testErrorLog
			testResults[totalTests]=6
			echo "Test result=Fail(bbservice exit!)" >> $testResultFile
		else
			echo "clientlite crash!" >> $testErrorLog
			testResults[totalTests]=6
			echo "Test result=Fail(clientlite exit!)" >> $testResultFile
		fi
	else
		# Stop all processes
		clean_up_all

		echo "clientlite not connected to daemon!" >> $testErrorLog
		testResults[totalTests]=6
		echo "Test result=Fail(clientlite not connected to daemon)" >> $testResultFile
	fi

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: bastress2ClientTest
# Description: run bastress2 client mode test
# Parameter: none
# Return: 
#	testResult is 0 if pass; 6 fail
function bastress2ClientTest() {
	$verbose && echo "bastress2 client mode test..." >> $testDetailLog

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))
	# is bastress2 connected to daemon: 0-yes, 1-no
	local bastress2Connected=0

	# Leave an empty line between tests in report
	echo >> $testResultFile

	echo "Test case=$testCase(tc bastress2 client)"
	echo "Test case=$testCase(tc bastress2 client)">> $testResultFile
	
	echo "<br>" >> $testResultHtml
	echo "<p>Test case=$testCase(tc bastress2 client)</p>">> $testResultHtml


	# Stop old daemon
	clean_up_all

	local daemonLog="daemon_bastress2_client.log"
	
	# Launch standard daemon for bastress2 to connect to 
	launchProcess "alljoyn-daemon" "" $daemonLog "tcp" 1 1 ""

	# The following paramter of three seconds is NEEDED as a work around
	# for bastress2 to connect to the daemon.
	sleep 3

	local bastress2Log="bastress2_client.log"

	# Start bastress2
	# Note: The order of starting alljoyn-daemon first and then starting bastress2
	#       is important. The chances of successful discovery are higher now.
	launchProcess "bastress2" "" $bastress2Log "tcp" 1 1 "-i 100 -t 1 -oc"
	
	# Wait some time for thin client to connect to pre-installed daemon
	sleep $waitForConnection

	echo "INFO: alljoyn-daemon started (pid $pid_of_daemon). Writing output to alljoyn-daemon.log."
	echo "INFO: bastress2 started (pid $pid_of_bastress2). Writing output to bastress2.log."
	
	# Perform a check that bastress2 was able to open a connection
	# to the port on which daemon is listening on.
	if ! lsof -i -n -P | grep $pid_of_bastress2 | grep -q $daemon_standard_port_number
	then
   	 	echo "ERROR: bastress2 was unable to connect to daemon. Cannot continue." >> $testErrorLog
    	bastress2Connected=1
	fi
	
	if [ "$bastress2Connected" -eq 0 ]; then
	
		# Sleep 90 seconds to make sure bastress2 does not crash
		sleep 90

		# make sure alljoyn-daemon, bbservice and clientlite are still running
		checkProcessCount "alljoyn-daemon" 1
		local daemonCount=$processCount

		checkProcessCount "bastress2" 1
		local bastress2Count=$processCount

		# Stop all processes
		clean_up_all
		
		# daemon and bastress2 should still run
		if [ "$daemonCount" -gt 0 -a "$bastress2Count" -gt 0 ]; then
			testResults[totalTests]=0
			echo "Test result=Pass" >> $testResultFile
			echo "<p>Test result=Pass</p>" >> $testResultHtml	
		elif [ "$daemonCount" -eq 0 ]; then
			echo "daemon crash!" >> $testErrorLog
			testResults[totalTests]=6
			echo "Test result=Fail(daemon crash!)" >> $testResultFile
			echo "<p>Test result=Fail(daemon crash!)</p>" >> $testResultHtml
		else
			echo "bastress2 crash!" >> $testErrorLog
			testResults[totalTests]=6
			echo "Test result=Fail(bastress2 crash!)" >> $testResultFile
			echo "<p>Test result=Fail(bastress2 crash!)</p>" >> $testResultHtml
		fi
	else
		# Stop all processes
		clean_up_all

		testResults[totalTests]=6
		echo "Test result=Fail(bastress2 connect to daemon fail!)" >> $testResultFile
		echo "<p>Test result=Fail(bastress2 connect to daemon fail!)</p>" >> $testResultHtml
	fi

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: bastress2ServiceTest
# Description: run bastress2 service mode test
# Parameter: none
# Return: 
#	testResult is 0 if pass; 6 fail
function bastress2ServiceTest() {
	$verbose && echo "bastress2 service mode test..." >> $testDetailLog

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))
	# is bastress2 connected to daemon: 0-yes, 1-no
	local bastress2Connected=0

	# Leave an empty line between tests in report
	echo >> $testResultFile

	echo "Test case=$testCase(tc bastress2 service)"
	echo "Test case=$testCase(tc bastress2 service)">> $testResultFile

	echo "<br>" >> $testResultHtml
	echo "<p>Test case=$testCase(tc bastress2 service)</p>">> $testResultHtml
	
	# Stop old daemon
	clean_up_all

	local daemonLog="daemon_bastress2_service.log"
	
	# Launch standard daemon for bastress2 to connect to 
	launchProcess "alljoyn-daemon" "" $daemonLog "tcp" 1 1 ""

	# The following paramter of three seconds is NEEDED as a work around
	# for bastress2 to connect to the daemon.
	sleep 3

	local bastress2Log="bastress2_service.log"

	# Start bastress2
	# Note: The order of starting alljoyn-daemon first and then starting bastress2
	#       is important. The chances of successful discovery are higher now.
	launchProcess "bastress2" "" $bastress2Log "tcp" 1 1 "-i 100 -t 1 -os"
	
	# Wait some time for thin client to connect to pre-installed daemon
	sleep $waitForConnection

	echo "INFO: alljoyn-daemon started (pid $pid_of_daemon). Writing output to alljoyn-daemon.log."
	echo "INFO: bastress2 started (pid $pid_of_bastress2). Writing output to bastress2_service.log."
	
	# Perform a check that bastress2 was able to open a connection
	# to the port on which daemon is listening on.
	if ! lsof -i -n -P | grep $pid_of_bastress2 | grep -q $daemon_standard_port_number
	then
   	 	echo "ERROR: bastress2 was unable to connect to daemon. Cannot continue." >> $testErrorLog
    	bastress2Connected=1
	fi
	
	if [ "$bastress2Connected" -eq 0 ]; then
	
		# Sleep 90 seconds to make sure bastress2 does not crash
		sleep 90

		# make sure alljoyn-daemon, bbservice and clientlite are still running
		checkProcessCount "alljoyn-daemon" 1
		local daemonCount=$processCount

		checkProcessCount "bastress2" 1
		local bastress2Count=$processCount

		# Stop all processes
		clean_up_all
		
		# daemon and bastress2 should still run
		if [ "$daemonCount" -gt 0 -a "$bastress2Count" -gt 0 ]; then
			testResults[totalTests]=0
			echo "Test result=Pass" >> $testResultFile
			echo "<p>Test result=Pass</p>" >> $testResultHtml		
		elif [ "$daemonCount" -eq 0 ]; then
			echo "daemon crash!" >> $testErrorLog
			testResults[totalTests]=6
			echo "Test result=Fail(daemon crash!)" >> $testResultFile
			echo "<p>Test result=Fail(daemon crash!)</p>" >> $testResultHtml
		else
			echo "bastress2 crash!" >> $testErrorLog
			testResults[totalTests]=6
			echo "Test result=Fail(bastress2 crash!)" >> $testResultFile
			echo "<p>Test result=Fail(bastress2 crash!)</p>" >> $testResultHtml
		fi
	else
		# Stop all processes
		clean_up_all

		testResults[totalTests]=6
		echo "Test result=Fail(bastress2 connect to daemon fail!)" >> $testResultFile
		echo "<p>Test result=Fail(bastress2 connect to daemon fail!)</p>" >> $testResultHtml
	fi

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: tcsExceedPDLimit
# Description: 
#	multiple thin clients(svclite) connected to pre-installed daemon, 
#	last svclite exceeds untrusted clients limit and can't connect
# Parameter: 
# 	untrustedLimit - how many thin clients can connect at most
# Return: 
#	testResult is 0 if pass; 6 fail
function tcsExceedPDLimit() {
	local untrustedLimit=$1
	local svcliteCnt=$(($untrustedLimit+1))

	$verbose && echo "thin clients connect to pre-installed daemon with limit $untrustedLimit ..." >> $testDetailLog

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile

	echo "Test case=$testCase(TCLCTP-49 thin clients exceed pd limit)"
	echo "Test case=$testCase(TCLCTP-49 thin clients exceed pd limit)">> $testResultFile

    echo "<br>" >> $testResultHtml
    echo "<p>Test case=$testCase(TCLCTP-49 thin clients exceed pd limit)</p>">> $testResultHtml
    
	# Need daemon config file which allow specified untrusted clients
	createDaemonConfig $untrustedLimit $tcDaemonName

	# Stop old daemon
	clean_up_all

	local daemonLog="daemon_untrusted_limit.log"
	
	# Launch standard daemon for svclite to connect to 
	launchProcess "alljoyn-daemon" "" $daemonLog "tcp" 1 1 ""

	# The following paramter of three seconds is NEEDED as a work around
	# for svclite to connect to the daemon.
	sleep 3

	local connectToOtherDaemon=0
	local failToConnect=0
	local lastSvcliteConnected=0

	for(( svcIndex=1; svcIndex<=$svcliteCnt; svcIndex++))
	do
		local svcliteLog="svclite_pd_${svcIndex}.log"

		# Start svclite
		# Note: The order of starting alljoyn-daemon first and then starting svclite
		#       is important. The chances of successful discovery are higher now.
		launchProcess "svclite" $svcname $svcliteLog "tcp" 1 1 ""

		# Wait for thin client to discover and connect
		sleep $waitForConnection
	
		connectToOtherDaemon=0
		failToConnect=0
		lastSvcliteConnected=0

		# Every svclite except last one should connect to daemon
		if [ "$svcIndex" -lt "$svcliteCnt" ]; then
			# Perform a check that svclite was able to open a connection
			# to the port on which daemon is listening on.
			if ! lsof -i -n -P | grep $pid_of_svclite | grep -q $daemon_standard_port_number
			then
				if lsof -i -n -P | grep $pid_of_svclite | grep ESTABLISHED
				then
	   			 	echo "In limit svclite connect to other daemon. Test block." >> $testErrorLog
    				connectToOtherDaemon=1
					break;
				else
					echo "In limit svclite fail to connect to any daemon. Test fail!" >> $testErrorLog
					failToConnect=1
					break;
				fi
			else
				echo "In limit svclite connect to expected daemon. Continue."
			fi
		else
			# Last svclite should NOT connect to daemon because exceeds untrusted clients limit
			if ! lsof -i -n -P | grep $pid_of_svclite | grep -q $daemon_standard_port_number
			then
				echo "Exceed limit svclite can not connect to daemon as expected, test pass."
				lastSvcliteConnected=0
				break;
			else
				echo "Exceed limit svclite connect to daemon unexpected, test fail!" >> $testErrorLog
				lastSvcliteConnected=1
				break;
			fi
		fi

	done


	if [ "$connectToOtherDaemon" -eq 1 ]; then
		testResults[totalTests]=5
		echo "Test result=Block(svclite connect to unexpected daemon)" >> $testResultFile
		echo "<p>Test result=Block(svclite connect to unexpected daemon)</p>" >> $testResultHtml
	elif [ "$failToConnect" -eq 1 ]; then
		testResults[totalTests]=6
		echo "Test result=Fail(svclite fail to connect)" >> $testResultFile
		echo "<p>Test result=Fail(svclite fail to connect)</p>" >> $testResultHtml
	elif [ "$lastSvcliteConnected" -eq 1 ]; then
		testResults[totalTests]=6
		echo "Test result=Fail(Exceed limit svclite connect)" >> $testResultFile
		echo "<p>Test result=Fail(Exceed limit svclite connect)</p>" >> $testResultHtml
	elif [ "$lastSvcliteConnected" -eq 0 ]; then

		# make sure alljoyn-daemon, bbservice and clientlite are still running
		checkProcessCount "alljoyn-daemon" 1
		local daemonCount=$processCount

		checkProcessCount "svclite" $svcliteCnt
		local svcliteCount=$processCount
		
		# daemon and svclite should still run
		if [ "$daemonCount" -gt 0 -a "$svcliteCount" -eq "$svcliteCnt" ]; then		
			testResults[totalTests]=0
			echo "Test result=Pass" >> $testResultFile
			echo "<p>Test result=Pass</p>" >> $testResultHtml
		elif [ "$daemonCount" -eq 0 ]; then
			echo "daemon crash!" >> $testErrorLog
			testResults[totalTests]=6
			echo "Test result=Fail(daemon crash!)" >> $testResultFile
			echo "<p>Test result=Fail(daemon crash!)</p>" >> $testResultHtml
		else
			echo "svclite crash!" >> $testErrorLog
			testResults[totalTests]=6
			echo "Test result=Fail(svclite crash!)" >> $testResultFile
			echo "<p>Test result=Fail(svclite crash!)</p>" >> $testResultHtml
		fi
	fi

	# Stop all processes
	clean_up_all

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: defineSecureInterface
# Description: 
#	define secure interface flag for specified file
# Parameter: 
#	fileName- file name (svclite.c etc)
# Return: 
#	defineStatus set to 0 - success; 1 - fail; 2 - file invalid
function defineSecureInterface() {
	local fileName=$1

	defineStatus=0
	$verbose && echo "define secure interface for $fileName"

	# file must exist
	if [ -e $fileName ]; then

		local defineOk=`grep "$secureDef" $fileName |wc -l`
		
		if [ $defineOk -gt 0 ]; then
			$verbose && echo "Secure interface for $fileName already defined"
		else

			# Add "#define SECURE_INTERFACE in the 1st line"
			sed -i '1i '"$secureDef"'' $fileName

			# Verify secure interface is defined
			defineOk=`grep "$secureDef" $fileName |wc -l`

			if [ $defineOk -gt 0 ]; then
				$verbose && echo "define success"
			else
				echo "define secure interface for $fileName fail for sed!" >> $testErrorLog
				defineStatus=1
			fi
		fi
	else
		$verbose && echo "define secure interface fail for nonexist $fileName !" >> $testErrorLog
		defineStatus=2
	fi
		
}

# Function name: undefSecureInterface
# Description: 
#	undefine secure interface flag for specified file
# Parameter: 
#	fileName- file name (svclite.c etc)
# Return: 
#	undefineStatus set to 0 - success; 1 - fail; 2 - file invalid
function undefSecureInterface() {
	local fileName=$1

	undefineStatus=0
	$verbose && echo "undefine secure interface for $fileName"

	# file must exist
	if [ -e $fileName ]; then

		# remove all occurances "#define SECURE_INTERFACE"
		sed -i '/'"$secureDef"'/d' $fileName

		# Verify secure interface is undefined
		local undefineOk=`grep "$secureDef" $fileName |wc -l`

		if [ $undefineOk -eq 0 ]; then
			$verbose && echo "undefine success"
		else
			echo "undefine secure interface for $fileName fail for sed!" >> $testErrorLog
			undefineStatus=1
		fi
	else
		$verbose && echo "undefine secure interface fail for nonexist $fileName !" >> $testErrorLog
		undefineStatus=2
	fi
}

# Function name: tcsExceedBDLimit
# Description: 
#	multiple thin clients(svclite) connected to debug bundled daemon app, 
#	last svclite exceeds untrusted clients limit in config.xml and can't connect
# Parameter: 
# 	untrustedLimit - Max thin clients can connect to bd
#	newName -  Daemon name for bundled daemon
# Return: 
#	testResult is 0 if pass; 6 fail
function tcsExceedBDLimit() {
	local untrustedLimit=$1
	local newName=$2

	local svcliteCnt=$(($untrustedLimit+1))

	$verbose && echo "thin clients connect bundled daemon anonymously with limit $untrustedLimit ..." >> $testDetailLog

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	local connectToOtherDaemon=0
	local failToConnect=0
	local lastSvcliteConnected=0

	# Leave an empty line between tests in report
	echo >> $testResultFile

	echo "Test case=$testCase(thin clients bd anonymous)"
	echo "Test case=$testCase(thin clients bd anonymous)">> $testResultFile

	# Stop old daemon
	clean_up_all

	if [ -e "$daemonConfigFile" ]; then
		# Generate config.xml for bbjoin to use
		cp $daemonConfigFile config.xml

		# release variant will not work
		if [[ $LinuxBinDir =~ $debugVariant ]]; then

			local bbjoinLog="daemon_bundled_bbjoin.log"
	
			# launchProcess "alljoyn-daemon" "" $daemonLog "tcp" 1 1 ""

			# Launch debug bbclient with bundled daemon for svclite to connect to 
			launchProcess "bbjoin" "" $bbjoinLog "tcp" 1 1 ""

			# The following paramter of three seconds is NEEDED as a work around
			# for svclite to connect to the daemon.
			sleep 3

			checkProcessCount "bbjoin" 1
			if [ "$processCount" -eq 1 ]; then
			
				if lsof -i -n -P | grep $pid_of_bbjoin | grep $daemon_standard_port_number
				then
					echo "bbjoin is listening on $daemon_standard_port_number"

					local svcCnt=1
	
					for(( svcCnt=1; svcCnt<=$svcliteCnt; svcCnt++))
					do
						local svcliteLog="svclite_bd_${svcCnt}.log"

						# Start svclite
						# Note: The order of starting alljoyn-daemon first and then starting svclite
						#       is important. The chances of successful discovery are higher now.
						launchProcess "svclite" $svcname $svcliteLog "tcp" 1 1 ""
	
						# Wait for thin client to discover and connect
						sleep $waitForConnection
		
						connectToOtherDaemon=0
						failToConnect=0
						lastSvcliteConnected=0
	
						checkProcessCount "svclite" $svcCnt
						if [ "$processCount" -ne "$svcCnt" ]; then
							echo "svclite $pid_of_svclite stopped!" >> $testErrorLog
						fi

						# Every svclite except last one should connect to daemon
						if [ "$svcCnt" -lt "$svcliteCnt" ]; then
							# Perform a check that svclite was able to open a connection
							# to the port on which daemon is listening on.
							if ! lsof -i -n -P | grep $pid_of_svclite | grep $daemon_standard_port_number
							then
								if lsof -i -n -P | grep $pid_of_svclite | grep ESTABLISHED
								then
				   			 		echo "svclite $pid_of_svclite connect to other daemon. Test block." >>$testErrorLog
	    							connectToOtherDaemon=1
									break;
								else
									echo "svclite $pid_of_svclite fail to connect to any daemon. Test fail!" >> $testErrorLog
									failToConnect=1
									break;
								fi
							else
								echo "In limit svclite connect to expected daemon. Continue."
							fi
						else
							# Last svclite should NOT connect to daemon because exceeds untrusted clients limit
							if ! lsof -i -n -P | grep $pid_of_svclite | grep $daemon_standard_port_number
							then
								echo "Exceed limit svclite can not connect to daemon as expected, test pass."
								lastSvcliteConnected=0
								break;
							else
								echo "Exceed limit svclite connect to daemon unexpected, test fail!" >> $testErrorLog
								lastSvcliteConnected=1
								break;
							fi
						fi
		
					done
	
					if [ "$connectToOtherDaemon" -eq 1 ]; then
						testResults[totalTests]=5
						echo "Test result=Block(svclite connect to unexpected daemon)" >> $testResultFile
					elif [ "$failToConnect" -eq 1 ]; then
						testResults[totalTests]=6
						echo "Test result=Fail(svclite fail to connect)" >> $testResultFile
					elif [ "$lastSvcliteConnected" -eq 1 ]; then
						testResults[totalTests]=6
						echo "Test result=Fail(Exceed limit svclite connect)" >> $testResultFile
					elif [ "$lastSvcliteConnected" -eq 0 ]; then
		
						# make sure alljoyn-daemon, bbservice and clientlite are still running
						checkProcessCount "bbjoin" 1
						local daemonCount=$processCount
	
						checkProcessCount "svclite" $svcliteCnt
						local svcliteCount=$processCount
			
						# daemon and svclite should still run
						if [ "$daemonCount" -gt 0 -a "$svcliteCount" -eq "$svcliteCnt" ]; then		
							testResults[totalTests]=0
							echo "Test result=Pass" >> $testResultFile
						elif [ "$daemonCount" -eq 0 ]; then
							echo "daemon crash!" >> $testErrorLog
							testResults[totalTests]=6
							echo "Test result=Fail(daemon crash!)" >> $testResultFile
						else
							echo "svclite crash!" >> $testErrorLog
							testResults[totalTests]=6
							echo "Test result=Fail(svclite crash!)" >> $testResultFile
						fi
					fi

					# Stop all processes
					clean_up_all
				
				else
					echo "bbjoin NOT listening on $daemon_standard_port_number !" >> $testErrorLog
					testResults[totalTests]=5
					echo "Test result=Block(bbjoin not use config.xml)" >> $testResultFile
				fi
			else
				echo "bbjoin $pid_of_bbjoin stopped!" >> $testErrorLog
				testResults[totalTests]=5
				echo "Test result=Block(bbjoin exit)" >> $testResultFile
			fi
		else
			testResults[totalTests]=5
			echo "Test result=Block(release variant)" >> $testResultFile
		fi
	else
		testResults[totalTests]=5
		echo "Test result=Block(daemon config file miss)" >> $testResultFile
	fi

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: checklitePinxOk
# Description: 
#	check each thin client log connected to TrustedTLSampleRN with PINX authentication
# Parameter: 
# 	logPrefix - log name prefix
# Return: 
#	connectedPinx is 0 if pass; 6 fail
# Notes:
# 	After AJCORE-4, SASL information is no longer printed for tc program unless 
#	dbgALL is set to 1 in aj_debug.c
function checklitePinxOk() {
	local logPrefix=$1

	connectedPinx=0

	# logs is an array which includes all tc logs
	local liteLogs=( `ls ${logPrefix}*` )
	
	local pinxRequest="SASL<-AUTH ALLJOYN_PIN_KEYX"
	local pinxServiceData="SASL->DATA"
	local pinxClientData="SASL<-DATA"
	local pinxApprove="SASL->OK"
	local pinxReject="SASL->REJECTED ALLJOYN_PIN_KEYX ANONYMOUS"

	for logFile in "${liteLogs[@]}"
	do
		if [ -e "$logFile" -a -s "$logFile" ]; then
			# check the following lines in log:
			#	SASL->
			#	SASL<-AUTH ALLJOYN_PIN_KEYX [xxxx]
			#	SASL->DATA [xxxxx]
			#	SASL<-DATA [xxxxx]
			#	SASL->OK [xxxx]
			#	SASL<-BEGIN 
			# If the following lines appear, then PINX fail:
			#	SASL->REJECTED ANONYMOUS
			#	SASL<-AUTH ANONYMOUS
			
			local pinxStarted=`strings $logFile | grep "$pinxRequest" |wc -l`
			local pinxFail=`strings $logFile | grep "$pinxReject" |wc -l`
			local pinxOk=`strings $logFile | grep "$pinxApprove" |wc -l`

			if [ "$pinxStarted" -eq 1 -a "$pinxOk" -eq 1 -a "$pinxFail" -eq 0 ]; then
				echo "$logFile SASL succeed with pinx"
			elif [ "$pinxStarted" -eq 0 ]; then
				echo "$logFile SASL pinx not started!" >> $testErrorLog
				connectedPinx=1
				break;
			elif [ "$pinxOk" -eq 0 ]; then
				echo "$logFile SASL pinx not completed!" >> $testErrorLog
				connectedPinx=1
				break;
			elif [ "$pinxFail" -eq 1 ]; then
				echo "$logFile SASL pinx fail!" >> $testErrorLog
				connectedPinx=1
				break;
			else
				echo "Other failures!"
				connectedPinx=1
				break;
			fi
				
		fi

	done

	if [ "$connectedPinx" -eq 0 ]; then
		echo "SASL pinx succeed for all tc logs start with $logPrefix"
	else
		echo "SASL pinx fail for one tc log start with $logPrefix"
	fi
}
# Function name: checkSocketEstablished
# Description: 
#	check if specified process has established open socket
# Parameter: 
# 	myPid - process id
# Return: 
#	establishedSocket is 0 if open socket established on process; 1 fail
function checkSocketEstablished() {
	local myPid=$1

	establishedSocket=1
	if lsof -i -n -P | grep $myPid | grep ESTABLISHED
	then
		echo "socket established"
		establishedSocket=0
	else
		echo "socket NOT established!" >> $testErrorlog
	fi

}

# Function name: secureSvcliteTest
# Description: 
#	bbclient can only call svclite secure interface if secure flag defined
# Parameter: 
#	newName -  Daemon name for bundled daemon
# Return: 
#	testResult is 0 if pass; 6 fail
function secureSvcliteTest() {
	local newName=$1

	$verbose && echo "bbclient can ONLY call svclite secure interface ..." >> $testDetailLog

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	local failToConnect=0

	# Leave an empty line between tests in report
	echo >> $testResultFile

	echo "Test case=$testCase(TCLCTP-50 secure interface)"
	echo "Test case=$testCase(TCLCTP-50 secure interface)">> $testResultFile

	# Stop old daemon
	clean_up_all

	local trustedTLSampleRNLog="daemon_secure.log"

	# Launch TrustedTLSampleRN for svclite to connect to 
	launchProcess "TrustedTLSampleRN" "$newName" $trustedTLSampleRNLog "tcp" 0 1 ""

	# The following paramter of three seconds is NEEDED as a work around
	# for svclite to connect to the daemon.
	sleep 3

	checkProcessCount "TrustedTLSampleRN" 1
	if [ "$processCount" -eq 1 ]; then
		# TrustedTLSampleRN listen on port 9955 or another port
		if lsof -i -n -P | grep $pid_of_trustedTLSampleRN | grep LISTEN
		then
			echo "TrustedTLSampleRN is listening on port"

			local svcCnt=1
	
			local svcliteLog="svclite_secure.log"

			# Start svclite
			# Note: The order of starting alljoyn-daemon first and then starting svclite
			#       is important. The chances of successful discovery are higher now.
			launchProcess "svclite" $svcname $svcliteLog "tcp" 1 1 ""
	
			# Wait for thin client to discover and connect
			sleep $waitForConnection
		
			failToConnect=0
	
			checkProcessCount "svclite" $svcCnt
			if [ "$processCount" -ne "$svcCnt" ]; then
				echo "svclite $pid_of_svclite stopped!" >> $testErrorLog
			fi

			# Perform a check that svclite was able to open a connection
			# to the port on which TrustedTLSampleRN is listening on.
			if ! lsof -i -n -P | grep $pid_of_svclite | grep ESTABLISHED
			then
				echo "svclite $pid_of_svclite fail to connect to any daemon. Test fail!" >> $testErrorLog
				failToConnect=1
			else
				echo "svclite connected to TrustedTLSampleRN. Continue."
			fi
						
			if [ "$failToConnect" -eq 1 ]; then
				testResults[totalTests]=6
				echo "Test result=Fail(svclite fail to connect)" >> $testResultFile
			else
				local bbclientSecureLog="bbclient_secure.log"
				local bbclientInsecureLog="bbclient_insecure.log"

				# bbclient successfully call secure interface of svclite
				# bbclient -d -n org.alljoyn.svclite -e ECDHE_PSK				
				launchProcess "bbclient" $svcname $bbclientSecureLog "tcp" 0 10 "-d -e ECDHE_PSK"

				# Wait 30 seconds to complete bbclient
				sleep 30

				# bbclient fail to call insecure interface of svclite
				# bbclient -d -n org.alljoyn.svclite
				launchProcess "bbclient" $svcname $bbclientInsecureLog "tcp" 0 10 "-d"

				# Wait 30 seconds to complete bbclient
				sleep 30

				# Check secure bbclient log
				decideLogWithKeys $bbclientSecureLog "$BBCLIENTCOMPLETE"
				local secureClientOk=$testResult

				# Check secure bbclient log
				decideLogWithKeys $bbclientInsecureLog "$BBCLIENTCOMPLETE"
				local insecureClientOk=$testResult
			
				# secure bbclient complete successfully and insecure bbclient fail
				if [ "$secureClientOk" -eq 0 -a "$insecureClientOk" -ne 0 ]; then		
				
					# make sure alljoyn-daemon, bbservice and clientlite are still running
					checkProcessCount "TrustedTLSampleRN" 1
					local daemonCount=$processCount
	
					checkProcessCount "svclite" 1
					local svcliteCount=$processCount
			
					# Stop all processes
					clean_up_all

					# daemon and svclite should still run
					if [ "$daemonCount" -eq 1 -a "$svcliteCount" -eq 1 ]; then
						
						testResults[totalTests]=0
						echo "Test result=Pass" >> $testResultFile
	
					elif [ "$daemonCount" -eq 0 ]; then
						echo "TrustedTLSampleRN crash!" >> $testErrorLog
						testResults[totalTests]=6
						echo "Test result=Fail(TrustedTLSampleRN crash!)" >> $testResultFile
					else
						echo "svclite crash!" >> $testErrorLog
						testResults[totalTests]=6
						echo "Test result=Fail(svclite crash!)" >> $testResultFile
					fi
				elif [ "$secureClientOk" -ne 0 ]; then
					echo "Secure bbclient fail!" >> $testErrorLog
					testResults[totalTests]=6
					echo "Test result=Fail(Secure bbclient fail!)" >> $testResultFile
				else
					echo "Insecure bbclient unexpectedly complete!" >> $testErrorLog
					testResults[totalTests]=6
					echo "Test result=Fail(InSecure bbclient pass!)" >> $testResultFile
				fi
			fi
				
		else
			echo "TrustedTLSampleRN NOT listening on any port !" >> $testErrorLog
			testResults[totalTests]=5
			echo "Test result=Block(TrustedTLSampleRN not listen on any port)" >> $testResultFile
		fi
	else
		echo "TrustedTLSampleRN $pid_of_trustedTLSampleRN stopped!" >> $testErrorLog
		testResults[totalTests]=5
		echo "Test result=Block(TrustedTLSampleRN crash)" >> $testResultFile
	fi

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: trustedTLSampleRNSvcliteFail
# Description: 
#	thin clients(svclite) unable to connect TrustedTLSampleRN with PINX for wrong password
# Parameter: 
# 	tcCount - Thin clients count
#	newName -  Daemon name for bundled daemon
# Return: 
#	testResult is 0 if pass; 6 fail
function trustedTLSampleRNSvcliteFail() {
	local tcCount=$1
	local newName=$2

	$verbose && echo "$tcCount svclites fail to connect TrustedTLSampleRN with PINX ..." >> $testDetailLog

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	local logPrefix="pinx_failure"

	# Leave an empty line between tests in report
	echo >> $testResultFile
	echo "Test case=$testCase(TCLCTP-54 PINX fail due to wrong password)"
	echo "Test case=$testCase(TCLCTP-54 PINX fail due to wrong password)">> $testResultFile

	# Stop old daemon
	clean_up_all

	local trustedTLSampleRNLog="daemon_sample_fail.log"

	# Launch TrustedTLSampleRN for svclite to connect to 
	launchProcess "TrustedTLSampleRN" "$newName" $trustedTLSampleRNLog "tcp" 0 1 ""

	# The following paramter of three seconds is NEEDED as a work around
	# for svclite to connect to the daemon.
	sleep 3

	checkProcessCount "TrustedTLSampleRN" 1
	if [ "$processCount" -eq 1 ]; then
		# TrustedTLSampleRN listen on port 9955 or another port
		if lsof -i -n -P | grep $pid_of_trustedTLSampleRN | grep LISTEN
		then
			echo "TrustedTLSampleRN is listening on port"

			local svcCnt=1
	
			for(( svcCnt=1; svcCnt<=$tcCount; svcCnt++))
			do
				local svcliteLog="${logPrefix}_${svcCnt}.log"

				# Start svclite
				# Note: The order of starting alljoyn-daemon first and then starting svclite
				#       is important. The chances of successful discovery are higher now.
				launchProcess "svclite" $svcname $svcliteLog "tcp" 1 1 ""
	
				# Wait for thin client to discover and connect
				sleep $waitForConnection
		
				checkProcessCount "svclite" $svcCnt
				if [ "$processCount" -ne "$svcCnt" ]; then
					echo "svclite $pid_of_svclite stopped!" >> $testErrorLog
				fi
		
			done
	
		
			# make sure TrustedTLSampleRN and svclite are still running
			checkProcessCount "TrustedTLSampleRN" 1
			local daemonCount=$processCount
	
			checkProcessCount "svclite" $tcCount
			local svcliteCount=$processCount

			# daemon and svclite should still run
			if [ "$daemonCount" -eq 1 -a "$svcliteCount" -eq "$tcCount" ]; then
				# Check TrustedTLSampleRN connection is NOT established
				checkSocketEstablished $pid_of_trustedTLSampleRN
				
				if [ "$establishedSocket" -ne 0 ]; then
					testResults[totalTests]=0
					echo "Test result=Pass" >> $testResultFile
				else
					echo "PINX success even wrong password!" >> $testErrorLog
					testResults[totalTests]=6
					echo "Test result=Fail(PINX success with wrong password!)" >> $testResultFile
				fi
			elif [ "$daemonCount" -eq 0 ]; then
				echo "TrustedTLSampleRN crash!" >> $testErrorLog
				testResults[totalTests]=6
				echo "Test result=Fail(TrustedTLSampleRN crash!)" >> $testResultFile
			else
				echo "svclite crash!" >> $testErrorLog
				testResults[totalTests]=6
				echo "Test result=Fail(svclite crash!)" >> $testResultFile
			fi
		else
			echo "TrustedTLSampleRN not listening!" >> $testErrorLog
			testResults[totalTests]=6
			echo "Test result=Fail(TrustedTLSampleRN not listening!)" >> $testResultFile	

		fi

	else
		echo "TrustedTLSampleRN $pid_of_trustedTLSampleRN stopped!" >> $testErrorLog
		testResults[totalTests]=5
		echo "Test result=Block(TrustedTLSampleRN crash)" >> $testResultFile
	fi

	# Stop all processes
	clean_up_all

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: remoteSigliteTest
# Description: 
#	bbservice receive 10 signals from siglite over remote bus
# Parameter: 
#	newName -  Daemon name for bundled daemon
# Return: 
#	testResult is 0 if pass; 6 fail
function remoteSigliteTest() {
	local newName=$1

	$verbose && echo "remote signal test..." >> $testDetailLog

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	local failToConnect=0

	# Leave an empty line between tests in report
	echo >> $testResultFile

	echo "Test case=$testCase(TCLCTP-17 siglite to bbservice)"
	echo "Test case=$testCase(TCLCTP-17 siglite to bbservice)">> $testResultFile

	# Stop old daemon
	clean_up_all

			
	local sigliteLog="siglite_remote_signal.log"

	# Start svclite
	launchProcess "siglite" $svcname $sigliteLog "tcp" $THIN_TEST 1 "-ek ECDHE_PSK"
	
	# Wait for thin client
	sleep 1
	
	local bbserviceLog="bbservice_siglite.log"

	# Launch bbsig with bundled daemon
	launchProcess "bbservice" $svcname $bbserviceLog "tcp" $BUNDLED_TEST 1 ""

	# Wait for bbservice to receive 10 signals
	sleep 90
	
	checkProcessCount "siglite" 1
	local sigliteLive=$processCount

	checkProcessCount "bbservice" 1
	local bbserviceLive=$processCount

	if [ "$sigliteLive" -ne 1 ]; then
		echo "siglite stopped!" >> $testErrorLog
		testResults[totalTests]=6
		echo "Test result=Fail(siglite crash)" >> $testResultFile
	elif  [ "$bbserviceLive" -ne 1 ]; then
		echo "bbservice stopped!" >> $testErrorLog
		testResults[totalTests]=6
		echo "Test result=Fail(bbservice crash)" >> $testResultFile
	elif ! lsof -i -n -P | grep $pid_of_siglite | grep ESTABLISHED
	then
		echo "siglite $pid_of_siglite fail to connect to routing node." >> $testErrorLog
		testResults[totalTests]=6
		echo "Test result=Fail(siglite fail to connect routing node)" >> $testResultFile
	else
		local signals_received=$(grep -c "$SIGRECEIVED" $bbserviceLog)
	
		if [ "$signals_received" -ge "$SIGLITEPINGS" ]; then
			testResults[totalTests]=0
			echo "Test result=Pass" >> $testResultFile		
		else
			testResults[totalTests]=6
			echo "Test result=Fail(bbservice $signals_received out of $SIGLITEPINGS signals)" >> $testResultFile		
		fi
	fi

	# Stop all processes
	clean_up_all

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: compareXmlLog
# Description: 
#	AJ_PrintXml test - verify that output match expected file
# Parameter: 
#	svcLog - svclite output file
#	expectedLog - expected output
# Return: 
#	compareOk is 0 if pass; 1 fail
function compareXmlLog() {
	local svcLog=$1
	local expectedLog=$2

	$verbose && echo "Comparing $svcLog with $expectedLog ..." >> $testDetailLog
	
	compareOk=1
	if [ -e "$svcLog" -a -s "$svcLog" ]; then
		local linesToCompare=`cat $expectedLog | wc -l`
		local xmlPart="svclite.head"

		$verbose && echo "Only compare $linesToCompare lines of $svcLog with $expectedLog ..." >> $testDetailLog
		
		strings $svcLog | head -n $linesToCompare > $xmlPart

		# ignore leading white space
		diff -w $xmlPart $expectedLog 1>>$testErrorLog 2>&1

		if [ "$?" -eq 0 ]; then
			echo "Compare successful"
			compareOk=0
		else
			echo "Compare mismatch, check $testErrorLog for detail!"
		fi
	else
		echo "$svcLog not exist or empty!"
	fi
}

# Function name: runLiteTests
# Description: run thin client tests
# Parameter: none
# Return: 
#	testResult is 0 if pass; 6 fail
function runLiteTests() {

	echo "Run lite tests..." >> $testDetailLog

	# aestest unit test
	aesTest

	# mutter unit test
	mutter

    # tc unit test
    ajtcltest
    
	# Need daemon config file which allow one untrusted client with default daemon name
	#  org.alljoyn.BusNode
	createDaemonConfig 1 $tcDaemonName

	# svclite/bbclient introspection test
	svcLiteIntroTest

	# clientlite/bbservice test
	#clientLiteTest

	# bastress2 client mode test
	bastress2ClientTest
	
	# bastress2 service mode test
	bastress2ServiceTest

	sleep 3

	# thin client daemon authentication tests

	# Launch 4 svclite with daemon limit of 3, first 3 svclite connect but last svclite fail
	tcsExceedPDLimit 3

}

# Function name: runajtcsctest
# Description: 
#   run thin client and standard client interaction unit test
# Parameter: none
# Return: none
function runajtcsctest() {
	echo "Run ajtcsctest..." >> $testDetailLog
	
	# Initialize result to fail
	testResults[totalTests]=6

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase(ajtcsctest)"
	echo "Test case=$testCase(ajtcsctest)">> $testResultFile
	echo "<p>Test case=$testCase(ajtcsctest)</p>">> $testResultHtml

	local ajtcsctestLog="${testDetailDir}ajtcsctest.log"

	# Stop everything
	clean_up_all
	
	# Launch ajtcltest
	launchProcess "ajtcsctest" "" $ajtcsctestLog "" 1 1 ""

	if [ "${tc_sc_status}" -eq 0 ]; then
		testResults[totalTests]=0
		echo "Test result=Pass" >> $testResultFile
		echo "<p>Test result=Pass</p>" >> $testResultHtml
	else	    
		local ajtcsctestError="${testDetailDir}ajtcsctest_error.txt"
		mv $ajtcsctestLog $ajtcsctestError
		if [ "${tc_sc_status}" -eq 124 ]; then
		    testResults[totalTests]=6
		    echo "Test result=Fail(hang)" >> $testResultFile
		    echo "<p>Test result=<a class="error" href="\"$ajtcsctestError\"">Fail(hang)</a></p>" >> $testResultHtml
	    else
	        testResults[totalTests]=6
		    echo "Test result=Fail(fail)" >> $testResultFile
		    echo "<p>Test result=<a class="error" href="\"$ajtcsctestError\"">Fail(fail)</a></p>" >> $testResultHtml
	    fi
	fi

	# Stop ajtcltest
	clean_up_all

	# Increse test count
	totalTests=$(($totalTests + 1))	

}

# Function name: runTcScInteraction
# Description: run thin client and standard client interaction tests
# Parameter: none
# Return: none
function runTcScInteraction() {
	echo "Run tc/sc interaction tests..." >> $testDetailLog
	
	#ajtcsctest
	if [ -x "${AJTCSCTEST_REL}" ]; then
	    runajtcsctest
	else
	    echo "Miss ${AJTCSCTEST_REL}"
	fi
}
# Function name: checkAboutSamples
# Description: 
#   check about samples exist in SDK 
# Parameter: 
#	binDir - about cpp samples binary path
#	coreLibDir - core cpp libary path
# Return: 
#	aboutSampleReady is set to 0 if about binaries and library exist; 1 otherwise 
function checkAboutSamples() {
	local binDir=$1
	local coreLibDir=$2
	echo "Copy liballjoyn_about.so to $coreLibDir ..." >> $testDetailLog

	local aboutService="${binDir}/AboutService"
	local aboutClient="${binDir}/AboutClient"

	aboutSampleReady=1

	if [ -d "$binDir" -a -d "$coreLibDir" ]; then
		if [ -e "$aboutService" -a -e "$aboutClient" ]; then
			$verbose && echo "about samples exist"
			aboutSampleReady=0
		else
			echo "about samples does NOT exist!" >> $testErrorLog
		fi
	else
		echo "$binDir or $coreLibDir does NOT exist!" >> $testErrorLog
	fi

}
# Function name: findBusName
# Description: 
#   Extract AboutService busName from log
# Parameter: 
#	serviceLog - about service log
# Return: 
#   serviceBusName is set to 
function findBusName() {
	echo "Extracting AboutService busName..." >> $testDetailLog
	local serviceLog=$1
	
	# successful service log include: 
	#  BusAttachment connect succeeded. BusName :y8T1M-Zo.2
	#  5th field is the busName
	serviceBusName=`grep "$BUSCONNECTED" $serviceLog | awk -F " " '{print $5}'`
	
	echo "AboutService busName $serviceBusName"
}

# Function name: decideAboutServiceResult
# Description: check about service log to decide test result
# Parameter: 
#	serviceLog - about service log
# Return: 
#	serviceStatus is 0 if pass; 
#   1 if bus connection fail; 2 if announce fail; 3 if accept session fail; 5 if log is empty
#   busName is extracted if busAttachment connect succeeded
function decideAboutServiceResult() {
	echo "check AboutService/AboutClient logs..." >> $testDetailLog
	local serviceLog=$1

	local busConnected=0
	local serviceAdvertised=0
	local serviceAccepted=0

	serviceStatus=${SERVICE_OK}
	
	# Check about service log
	if [ -e "$serviceLog" -a -s "$serviceLog" ]; then
		busConnected=`grep "$BUSCONNECTED" $serviceLog|wc -l`

		if [ "$busConnected" -eq 1 ]; then
			serviceAdvertised=`grep "$ABOUTADVERTISED" $serviceLog|wc -l`

			if [ "$serviceAdvertised" -eq 1 ]; then
				serviceAccepted=`egrep "$SESSIONJOINED" $serviceLog|wc -l`
					
				if [ "$serviceAccepted" -eq 1 ]; then
				    findBusName $serviceLog
				    # service bus name should NOT be empty
				    if [ -z "$serviceBusName" ]; then
				        echo "About Service bus name is wrong!"
				        serviceStatus=${SERVICE_BUS_FAIL}
				    else
					    echo "About Service log looks good" >> $testDetailLog
					    serviceStatus=${SERVICE_OK}
					fi
				else
					echo "About Service failed to accept joinSession request!" >> $testErrorLog
					serviceStatus=${SERVICE_ACCEPT_SESSION_FAIL}
				fi
			else
				echo "About Service announcement failed!" >> $testErrorLog
				serviceStatus=${SERVICE_ANNOUNCE_FAIL}
			fi
		else
			echo "About Service bus attachment failed!" >> $testErrorLog
			serviceStatus=${SERVICE_BUS_FAIL}
		fi
		
	else
		echo "$serviceLog is empty!" >> $testErrorLog
		# Unable to check service status
		serviceStatus=${SERVICE_EMPTY_LOG}
	fi

}

# Function name: decideAboutClientResult
# Description: check about client log to decide test result
# Parameter: 
#	clientLog - about client log
#   busName   - service bus name which annoucement is sent
# Return: 
#	clientStatus is 0 if pass; 
#   1 if bus connection fail; 2 if no annoucement received; 5 for empty log
function decideAboutClientResult() {
	echo "check AboutClient log..." >> $testDetailLog
	local clientLog=$1
    local busName=$2
    
    local clientBusConnected=0
    local clientGetAnnouncement=0
    
	clientStatus=${CLIENT_OK}	
		
	# Check about client log
	# We don't want to check announcement data detail since certification test do that
	# We only check bus connection and announcement from service bus
	if [ -e "$clientLog" -a -s "$clientLog" ]; then
	
	    clientBusConnected=`grep "$BUSCONNECTED" $clientLog|wc -l`
	    
        if [ "$clientBusConnected" -eq 1 ]; then
    	    local fromBusWords="${FROMBUS} ${busName}"
	        local clientGetAnnouncement=`grep "$fromBusWords" $clientLog |wc -l`
	    
	        if [ "$clientGetAnnouncement" -eq 1 ]; then
                clientStatus=${CLIENT_OK}
		    else
			    echo "About client not receive announcement ${fromBusWords} !" >> $testErrorLog
			    clientStatus=${CLIENT_MISS_ANNOUNCEMENT}
		    fi
		else
		    echo "About client bus NOT connected!" >> $testErrorLog
		    clientStatus=${CLIENT_BUS_FAIL}
		fi
	else
		echo "$clientLog is empty!" >> $testErrorLog
		clientStatus=${CLIENT_EMPTY_LOG}
	fi

}

# Function name: runAboutServiceClient
# Description: run AboutService and AboutClient samples
# Parameter: none
# Return: 
#	testResult is 0 if pass; 6 fail
function runAboutServiceClient() {
	echo "AboutService/AboutClient..." >> $testDetailLog

	# Initialize result to success
	#testResults[totalTests]=0

	# Test case 
	#local testCase=$(($totalTests + 1))
	# Leave an empty line between tests in report
	echo >> $testResultFile
	echo "<br>" >> $testResultHtml
	
	echo "Test case=$testCase(AboutService/Client)"
	echo "Test case=$testCase(AboutService/Client)">> $testResultFile
    echo "<p>Test case=$testCase(AboutService/Client)</p>">> $testResultHtml
    
	local aboutserviceLog="${testDetailDir}${scriptName}_${testCase}_aboutservice.log"
	local aboutclientLog="${testDetailDir}${scriptName}_${testCase}_aboutclient.log"

	# Stop existing pre-installed daemon, AboutService and AboutClient running
	killProcess "alljoyn-daemon"

	killProcess "AboutService"

	killProcess "AboutClient"

	# Launch AboutService with BUS_ADDRESS=""
	launchProcess "AboutService" "" $aboutserviceLog "" 0 1 ""

	# Make sure AboutService is launched
	sleep 5

	# Confirm only one process is launched
	checkProcessCount "AboutService" 1	

	if [ "$processCount" -ne 1 ]; then
		echo "AboutService launch failure" >> $testErrorLog
		#testResults[totalTests]=6
		echo "Test result=Fail(AboutService crash)" >> $testResultFile
		echo "<p>Test result=Fail(AboutService crash)</p>" >> $testResultHtml
	else
		# Launch AboutClient with BUS_ADDRESS=""
		launchProcess "AboutClient" "" $aboutclientLog "" 0 1 ""

		# Make sure discovery, announce handler, joinSession complete
		sleep 60

		# Check AboutService and AboutClient log to decide Pass/Fail
		decideAboutServiceResult $aboutserviceLog

		decideAboutClientResult $aboutclientLog $serviceBusName

		if [ "$serviceStatus" -eq 0 -a "$clientStatus" -eq 0 ]; then
			#testResults[totalTests]=0
			echo "Test result=Pass" >> $testResultFile
			echo "<p>Test result=Pass</p>" >> $testResultHtml
		elif [ "$serviceStatus" -ne 0 ]; then
		    # Empty AboutService log, test blocked
		    if [ "$serviceStatus" -eq "${SERVICE_EMPTY_LOG}" ]; then
		        #testResults[totalTests]=5
			    echo "Test result=Block(Service empty log)" >> $testResultFile
			    echo "<p>Test result=Block(Service empty log)</p>" >> $testResultHtml
			else
			    local aboutserviceError="${testDetailDir}${scriptName}_${testCase}_aboutservice_error.txt"
	            mv $aboutserviceLog $aboutserviceError
	            
	            #testResults[totalTests]=6
			    if [ "$serviceStatus" -eq "${SERVICE_BUS_FAIL}" ]; then	            
			        echo "Test result=Fail(service bus)" >> $testResultFile
			        echo "<p>Test result=Fail(<a class="error" href="\"$aboutserviceError\"">service bus</a>)</p>" >> $testResultHtml
			    elif [ "$serviceStatus" -eq "${SERVICE_ANNOUNCE_FAIL}" ]; then
			        echo "Test result=Fail(service announce)" >> $testResultFile
			        echo "<p>Test result=Fail(<a class="error" href="\"$aboutserviceError\"">service annouce</a>)</p>" >> $testResultHtml
	            else
			        echo "Test result=Fail(service session)" >> $testResultFile
			        echo "<p>Test result=Fail(<a class="error" href="\"$aboutserviceError\"">service session</a>)</p>" >> $testResultHtml
			    fi
			fi
		else
		
			# Empty AboutClient log, test blocked
		    if [ "$clientStatus" -eq "${CLIENT_EMPTY_LOG}" ]; then
		        #testResults[totalTests]=5
			    echo "Test result=Block(Client empty log)" >> $testResultFile
			    echo "<p>Test result=Block(Client empty log)</p>" >> $testResultHtml
			else
			    local aboutclientError="${testDetailDir}${scriptName}_${testCase}_aboutclient_error.txt"
		        mv $aboutclientLog $aboutclientError
	            
	            #testResults[totalTests]=6
			    if [ "$clientStatus" -eq "${CLIENT_BUS_FAIL}" ]; then	            
			        echo "Test result=Fail(client bus)" >> $testResultFile
			        echo "<p>Test result=Fail(<a class="error" href="\"$aboutclientError\"">client bus</a>)</p>" >> $testResultHtml
			    else
			        echo "Test result=Fail(client miss announce)" >> $testResultFile
			        echo "<p>Test result=Fail(<a class="error" href="\"$aboutclientError\"">client miss announce</a>)</p>" >> $testResultHtml
	           
			    fi
			fi
		fi
	fi

	# Cleanup
	killProcess "AboutService"

	killProcess "AboutClient"

	sleep 2

	# Increse test count
	#totalTests=$(($totalTests + 1))	

}

# Function name: runAboutSamples
# Description: 
#   run 1412 release about samples AboutService and AboutClient 
# Parameter: none
# Return: 
#	testResult is 0 if pass; 3 fail
function runAboutSamples() {
	echo "Run about tests..." >> $testDetailLog

	# check about binaries and library
	checkAboutSamples "$aboutSampleDir" "$LinuxLibDir"

	if [ "$aboutSampleReady" -eq 0 ]; then
		# run AboutService/AboutClient test
		runAboutServiceClient
	
		# AboutServiceFullSecondLangauge/AboutClient test

		# AboutServiceOnlymandatorySecondLangauge/AboutClient test
	else
		echo "Ignore about test since about binaries or library not available" >> $testErrorLog
	fi
		
}

# Function name: TwoRemoteClients
# Description: two remote bbclients test
# Parameter: none
# Return: 
#	testResult is 0 if pass; 3 fail
function TwoRemoteClients() {
	echo "Two remote clients ..." >> $testDetailLog
	
	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile

	echo "Test case=$testCase(multipoint session-two remote bbclients)"
	echo "Test case=$testCase(multipoint session-two remote bbclients)">> $testResultFile

	# Stop old daemon
	clean_up_all

	local daemonLog="daemon_multipoint1.log"
	
	# Launch pre-installed daemon so bbservice and local client can connect to
	launchProcess "alljoyn-daemon" "" $daemonLog "" 0 1 ""

	sleep 2

	local name="gov.m1"
	local serviceLog="${testDetailDir}${scriptName}_${testCase}_mp_bbservice.log"

	# Launch bbservice with multipoint option on all transports
	launchProcess "bbservice" $name $serviceLog "tcp" 0 1 "-m"
	
	sleep 2

	# Launch two remote bbclients
	local remoteClient1Log="${testDetailDir}${scriptName}_${testCase}_remote_bbclient1.log"
	local remoteClient2Log="${testDetailDir}${scriptName}_${testCase}_remote_bbclient2.log"

	launchProcess "bbclient" $name $remoteClient1Log "tcp" 0 1000 "-d"

	sleep 2

	launchProcess "bbclient" $name $remoteClient2Log "tcp" 0 1000 "-d"
	
	# wait 2 min so all clients should complete 
	sleep 120

	# Check all clients complete successfully
	decideLogWithKeys $remoteClient1Log "$BBCLIENTCOMPLETE"

	if [ "$testResult" -eq 0 ]; then
		decideLogWithKeys $remoteClient2Log "$BBCLIENTCOMPLETE"
			
		if [ "$testResult" -eq 0 ]; then
			testResults[totalTests]=0
			echo "Test result=Pass" >> $testResultFile
		else
			testResults[totalTests]=6
			echo "Test result=Fail(remote bbclient2)" >> $testResultFile
		fi
	else
		testResults[totalTests]=6
		echo "Test result=Fail(remote bbclient1)" >> $testResultFile
	fi


	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: LocalRemoteClients
# Description: one local client then two remote bbclients
# Parameter: none
# Return: 
#	testResult is 0 if pass; 3 fail
function LocalRemoteClients() {
	echo "One local client then two remote clients ..." >> $testDetailLog
	
	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile

	echo "Test case=$testCase(multipoint session-one local then two remote bbclients)"
	echo "Test case=$testCase(multipoint session-one local then two remote bbclients)">> $testResultFile

	# Stop old daemon
	clean_up_all

	local daemonLog="daemon_multipoint2.log"
	
	# Launch pre-installed daemon so bbservice and local client can connect to
	launchProcess "alljoyn-daemon" "" $daemonLog "" 0 1 ""

	sleep 2

	local name="gov.m2"
	local serviceLog="${testDetailDir}${scriptName}_${testCase}_mp2_bbservice.log"

	# Launch bbservice with multipoint option on all transports
	launchProcess "bbservice" $name $serviceLog "tcp" 0 1 "-m"

	sleep 2
	
	# Launch local bbclient
	local localClientLog="${testDetailDir}${scriptName}_${testCase}_local_bbclient.log"
	
	launchProcess "bbclient" $name $localClientLog "local" 0 1000 ""

	sleep 2

	# Launch two remote bbclients
	local remoteClient1Log="${testDetailDir}${scriptName}_${testCase}_remote_bbclient1.log"
	local remoteClient2Log="${testDetailDir}${scriptName}_${testCase}_remote_bbclient2.log"

	launchProcess "bbclient" $name $remoteClient1Log "tcp" 0 1000 "-d"

	sleep 2

	launchProcess "bbclient" $name $remoteClient2Log "tcp" 0 1000 "-d"

	# wait 2 min so all clients should complete 
	sleep 120

	# Check all clients complete successfully
	decideLogWithKeys $localClientLog "$BBCLIENTCOMPLETE"

	if [ "$testResult" -eq 0 ]; then
		decideLogWithKeys $remoteClient1Log "$BBCLIENTCOMPLETE"
			
		if [ "$testResult" -eq 0 ]; then
			decideLogWithKeys $remoteClient2Log "$BBCLIENTCOMPLETE"
			
			if [ "$testResult" -eq 0 ]; then
				testResults[totalTests]=0
				echo "Test result=Pass" >> $testResultFile
			else
				testResults[totalTests]=6
				echo "Test result=Fail(remote bbclient2)" >> $testResultFile
			fi
		else
			testResults[totalTests]=6
			echo "Test result=Fail(remote bbclient1)" >> $testResultFile
		fi
	else
		testResults[totalTests]=6
		echo "Test result=Fail(local bbclient)" >> $testResultFile
	fi


	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: runSCIntrospection
# Description: sc end-end messaging introspection
# Parameter:
#	launchDaemon - if pre-installed daemon is launched first (0-no; 1-yes)
# Return: 
#	testResult is 0 if pass; 3 fail
function runSCIntrospection() {
	echo "SC end-end messaging introspection test ..." >> $testDetailLog
	
	local launchDaemon=$1
	local testMap="no pid"

	if [ "$launchDaemon" -eq 1 ]; then
		testMap="pid"
	fi

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase($testMap end-end messaging introspection)"
	echo "Test case=$testCase($testMap end-end messaging introspection)">> $testResultFile
	echo "<p>Test case=$testCase($testMap end-end messaging introspection)</p>">> $testResultHtml

	# Stop old daemon
	clean_up_all

	if [ "$launchDaemon" -eq 1 ]; then
		local daemonLog="daemon_introspection.log"
	
		# Launch pre-installed daemon
		launchProcess "alljoyn-daemon" "" $daemonLog "" 0 1 ""

		sleep 2
	fi

	local wkName="org.intros$testCase"
	echo "Introspection test well-known name is $wkName"

	local serviceLog="${testDetailDir}${scriptName}_${testCase}_intros_bbservice.log"

	# Launch bbservice
	launchProcess "bbservice" $wkName $serviceLog "tcp" 0 1 ""

	sleep 2
	
	# Launch bbclient with introspection option: 0 means bundled daemon
	local clientLog="${testDetailDir}${scriptName}_${testCase}_intros_bbclient.log"
	
	launchProcess "bbclient" $wkName $clientLog "tcp" 0 100 "-d -i"

	# wait 1 min so bbclient complete 
	sleep 60

	# cleanup
	clean_up_all

	# Check all clients complete successfully
	decideLogWithKeys $clientLog "$BBCLIENTCOMPLETE"

	if [ "$testResult" -eq 0 ]; then
		testResults[totalTests]=0
		echo "Test result=Pass" >> $testResultFile
		echo "<p>Test result=Pass</p>" >> $testResultHtml
	else
	    local clientError="${testDetailDir}${scriptName}_${testCase}_intros_bbclient_error.txt"
	    mv $clientLog $clientError
		testResults[totalTests]=6
		echo "Test result=Fail(remote bbclient2)" >> $testResultFile
		echo "<p>Test result=Fail(<a class="error" href="\"$clientError\"">bbclient</a>)</p>" >> $testResultHtml
	fi

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: runSCAsyncCall
# Description: sc end-end messaging asynchronous method calls
# Parameter:
#	launchDaemon - if pre-installed daemon is launched first (0-no; 1-yes)
# Return: 
#	testResult is 0 if pass; 3 fail
function runSCAsyncCall() {
	echo "SC end-end messaging asynchronous method call test ..." >> $testDetailLog
	
	local launchDaemon=$1
	local testMap="no pid"

	if [ "$launchDaemon" -eq 1 ]; then
		testMap="pid"
	fi

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase($testMap end-end messaging async method call)"
	echo "Test case=$testCase($testMap end-end messaging async method call)">> $testResultFile
    echo "<p>Test case=$testCase($testMap end-end messaging async method call)</p>">> $testResultHtml
    
	# Stop old daemon
	clean_up_all

	if [ "$launchDaemon" -eq 1 ]; then
		local daemonLog="daemon_async.log"
	
		# Launch pre-installed daemon
		launchProcess "alljoyn-daemon" "" $daemonLog "" 0 1 ""

		sleep 2
	fi

	local wkName="org.asyn$testCase"
	echo "Asynchronous method call test well-known name is $wkName"

	local serviceLog="${testDetailDir}${scriptName}_${testCase}_async_bbservice.log"

	# Launch bbservice
	launchProcess "bbservice" $wkName $serviceLog "tcp" 0 1 ""

	sleep 2
	
	# Launch bbclient with introspection option
	local clientLog="${testDetailDir}${scriptName}_${testCase}_async_bbclient.log"
	
	launchProcess "bbclient" $wkName $clientLog "tcp" 0 100 "-d -dpa 1"

	# wait 90second so bbclient complete 
	sleep 90

	# cleanup
	clean_up_all

	# Check bbclient complete successfully
	decideLogWithKeys $clientLog "$BBCLIENTCOMPLETE"

	if [ "$testResult" -eq 0 ]; then
		testResults[totalTests]=0
		echo "Test result=Pass" >> $testResultFile
		echo "<p>Test result=Pass</p>" >> $testResultHtml
	else
	    local clientError="${testDetailDir}${scriptName}_${testCase}_async_bbclient_error.txt"
	    mv $clientLog $clientError
		testResults[totalTests]=6
		echo "Test result=Fail(bbclient fail)" >> $testResultFile
		echo "<p>Test result=Fail(<a class="error" href="\"$clientError\"">bbclient fail</a>)" >> $testResultHtml
	fi

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: runSCSyncAsyncMix
# Description: 
#	sc end-end messaging synchronous and asynchronous method calls
# Parameter:
#	launchDaemon - if pre-installed daemon is launched first (0-no; 1-yes)
# Return: 
#	testResult is 0 if pass; 3 fail
function runSCSyncAsyncMix() {
	echo "SC end-end messaging synchronous and asynchronous mix test ..." >> $testDetailLog
	
	local launchDaemon=$1
	local testMap="no pid"

	if [ "$launchDaemon" -eq 1 ]; then
		testMap="pid"
	fi

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase($testMap end-end messaging sync/async method call)"
	echo "Test case=$testCase($testMap end-end messaging sync/async method call)">> $testResultFile
	echo "<p>Test case=$testCase($testMap end-end messaging sync/async method call)</p>">> $testResultHtml

	# Stop old daemon
	clean_up_all

	if [ "$launchDaemon" -eq 1 ]; then
		local daemonLog="daemon_sync_async.log"
	
		# Launch pre-installed daemon
		launchProcess "alljoyn-daemon" "" $daemonLog "" 0 1 ""

		sleep 2
	fi

	local wkName="org.mix$testCase"
	echo "Asynchronous method call test well-known name is $wkName"

	# Launch bbclient async
	local asynClientLog="${testDetailDir}${scriptName}_${testCase}_async_bbclient.log"
	
	launchProcess "bbclient" $wkName $asynClientLog "tcp" 0 1000 "-d -dpa 1"

	sleep 1

	# Launch bbclient async
	local synClientLog="${testDetailDir}${scriptName}_${testCase}_sync_bbclient.log"
	
	launchProcess "bbclient" $wkName $synClientLog "tcp" 0 100 "-d"

	sleep 1
	
	local serviceLog="${testDetailDir}${scriptName}_${testCase}_mix_bbservice.log"

	# Launch bbservice
	launchProcess "bbservice" $wkName $serviceLog "tcp" 0 1 ""

	# wait 90s so bbclient complete 
	sleep 90

	# cleanup
	clean_up_all

	# Check async bbclient complete successfully
	decideLogWithKeys $asynClientLog "$BBCLIENTCOMPLETE"
	local asynResult=$testResult

	# Check sync bbclient complete successfully
	decideLogWithKeys $synClientLog "$BBCLIENTCOMPLETE"
	local synResult=$testResult

	if [ "$asynResult" -eq 0 -a "$synResult" -eq 0 ]; then
		testResults[totalTests]=0
		echo "Test result=Pass" >> $testResultFile
		echo "<p>Test result=Pass</p>" >> $testResultHtml
	elif [ "$$asynResult" -ne 0 ]; then
	    local asynClientError="${testDetailDir}${scriptName}_${testCase}_async_bbclient_error.txt"
	    mv $asynClientLog $asynClientError
		testResults[totalTests]=6
		echo "Test result=Fail(asyn bbclient fail)" >> $testResultFile
		echo "<p>Test result=Fail(<a class="error" href="\"$asynClientError\"">asyn bbclient fail</a>)</p>" >> $testResultHtml
	else
	    local synClientError="${testDetailDir}${scriptName}_${testCase}_sync_bbclient_error.txt"
	    mv $synClientLog $synClientError
		testResults[totalTests]=6
		echo "Test result=Fail(syn bbclient fail)" >> $testResultFile
		echo "<p>Test result=Fail(<a class="error" href="\"$synClientError\"">syn bbclient fail</a>)</p>" >> $testResultHtml
	fi

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: runSharedKeyStore
# Description: sc end-end messaging shared key store
# Parameter:
#	launchDaemon - if pre-installed daemon is launched first (0-no; 1-yes)
# Return: 
#	testResult is 0 if pass; 3 fail
function runSharedKeyStore() {
	echo "SC end-end messaging shared key store test ..." >> $testDetailLog
	
	local launchDaemon=$1
	local testMap="no pid"

	if [ "$launchDaemon" -eq 1 ]; then
		testMap="pid"
	fi

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile

	echo "Test case=$testCase($testMap end-end messaging shared keystore)"
	echo "Test case=$testCase($testMap end-end messaging shared keystore)">> $testResultFile

	# Stop old daemon
	clean_up_all

    # Clean keystore
    cleanKeystore
    
	if [ "$launchDaemon" -eq 1 ]; then
		local daemonLog="daemon_shared_ks.log"
	
		# Launch pre-installed daemon
		launchProcess "alljoyn-daemon" "" $daemonLog "" 0 1 ""

		sleep 2
	fi

	local wkName="org.ks$testCase"
	echo "Shared keystore test well-known name is $wkName"

	local serviceLog="${testDetailDir}${scriptName}_${testCase}_ks_bbservice.log"

	# Launch bbservice
	launchProcess "bbservice" $wkName $serviceLog "tcp" 0 1 "-k sharedkeystore"

	sleep 2

	# Launch bbclient with logon shared keystore option
	local logonClientLog="${testDetailDir}${scriptName}_${testCase}_logon_ks_bbclient.log"
	
	launchProcess "bbclient" $wkName $logonClientLog "tcp" 0 1000 "-d -ek LOGON happy -k sharedkeystore"

	sleep 2

	# Launch bbclient with srp shared keystore option
	local srpClientLog="${testDetailDir}${scriptName}_${testCase}_srp_ks_bbclient.log"
	
	launchProcess "bbclient" $wkName $srpClientLog "tcp" 0 1000 "-d -ek SRP -k sharedkeystore"

	# wait 2 min so bbclient complete 
	sleep 120

	# cleanup
	clean_up_all

	# Check LOGON bbclient complete successfully
	decideLogWithKeys $logonClientLog "$BBCLIENTCOMPLETE"
	logonResult=$testResult

	# Check SRP bbclient complete successfully
	decideLogWithKeys $srpClientLog "$BBCLIENTCOMPLETE"
	srpResult=$testResult

	if [ "$logonResult" -eq 0 -a "$srpResult" -eq 0 ]; then
		testResults[totalTests]=0
		echo "Test result=Pass" >> $testResultFile
	elif [ "$logonResult" -ne 0 ]; then
		testResults[totalTests]=6
		echo "Test result=Fail(LOGON bbclient fail)" >> $testResultFile
	else
		testResults[totalTests]=6
		echo "Test result=Fail(SRP bbclient fail)" >> $testResultFile
	fi

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: renameCoreDump
# Description: 
#	rename core file for current test so later core file won't overwrite it 
# Parameter: 
#	newCoreName - new core dump file name
# Return: 
#	coreDump flag is set to 1 if core dump file exists
function renameCoreDump() {
	local newCoreName=$1

	echo "Renaming core dump file to $newCoreName ..." >> $testDetailLog
    coreDump=0
    
	local coreFile="${testResultDir}core"
	local newCore="${testResultDir}${newCoreName}"

	if [ -e "$coreFile" ]; then
		$verbose && echo "core exist"
		coreDump=1
		mv $coreFile $newCore
	else
		$verbose && echo "core not exist, forget it"
	fi
}
# Function name: analyzeCoreDump
# Description: 
#	analyze core dump and generate core stack output 
# Parameter: 
#   testProgram - test program crashed
#	coreDump    - core dump file name
#   outputStack - output stack file
# Return: 
#	coreStackReady is set to 1 if succeed; 0 otherwise
function analyzeCoreDump() {
	local testProgram=$1
	local coreDump=$2
	local outputStack=$3

	echo "Analyzing core dump $coreDump for $testProgram ..." >> $testDetailLog

	coreStackReady=0
	
	local analysisScript="${expectScriptDir}/get_dump_stack.exp"
	local tmpFile="stackTmp.log"
	
	if [ -d "${expectScriptDir}" -a -x "${analysisScript}" ]; then
	    
	    # Launch get_dump_stack.exp 
	    timeout 90 $analysisScript $testProgram $coreDump $tmpFile >$outputStack 2>/dev/null
        
        if [ -e "$outputStack" -a -s "$outputStack" ]; then
            coreStackReady=1
			echo "Analysis OK, stack output $outputStack ready" >> $testDetailLog
	    else
	        echo "Analysis fail, stack output $outputStack unavailable" >> $testErrorLog
		fi
    fi
}

# Function name: runBbsigStress
# Description: 
#	bbservice/bbsig stress test
# Parameter: none
# Return: 
#	testResult is 0 if pass; 3 fail
function runBbsigStress() {
	
	echo "SC bbservice/bbsig stress test ..." >> $testDetailLog
	
	local testMap="stress signal"

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase($testMap)"
	echo "Test case=$testCase($testMap)">> $testResultFile
	echo "<p>Test case=$testCase($testMap)</p>">> $testResultHtml

	# Stop old daemon
	clean_up_all

	local wkName="com.signals"
	echo "bbsig stress test well-known name is $wkName"

	local serviceLog="${testDetailDir}${scriptName}_${testCase}_stress_bbservice.log"

	# Launch bbservice
	launchProcess "bbservice" $wkName $serviceLog "tcp" $STRESS_TEST 1 ""

	sleep 2
	
	# Launch bbsig with shared keystore option
	local bbsigLog="${testDetailDir}${scriptName}_${testCase}_stress_bbsig.log"
	
	launchProcess "bbsig" $wkName $bbsigLog "tcp" $STRESS_TEST 10 "-d -s -i 1"

	# wait 5 min 
	sleep 300

	# Check bbsig or bbservice still live
	checkProcessCount "bbservice" 1
	local bbserviceLive=$processCount
	echo "After stress bbservice count $bbserviceLive"

	checkProcessCount "bbsig" 1
	local bbsigLive=$processCount
	echo "After stress bbsig count $bbsigLive"

	# Both bbsig and bbservice should be alive
	if [ "$bbserviceLive" -eq 1 -a "$bbsigLive" -eq 1 ]; then
		testResults[totalTests]=0
		echo "Test result=Pass" >> $testResultFile
		echo "<p>Test result=Pass</p>" >> $testResultHtml
	elif [ "$bbsigLive" -eq 0 ]; then
		testResults[totalTests]=6
		renameCoreDump "bbsig_stress_core"
		echo "Test result=Fail(bbsig crash,check bbsig_stress_core)" >> $testResultFile
		if [ "$coreDump" -eq 1 ]; then
		    local bbsigCallStack="bbsig_stress_crash_error.txt"
	        analyzeCoreDump "${LinuxDbgBinDir}/bbsig" "bbsig_stress_core" "$bbsigCallStack"
	        echo "<p>Test result=Fail(bbsig crash,check <a class="error" href="\"$bbsigCallStack\"">log</a>)</p>" >> $testResultHtml
	    else
	        echo "<p>Test result=Fail(bbsig crash,core dump miss)</p>" >> $testResultHtml
	    fi	

	elif [ "$bbserviceLive" -eq 0 ]; then
		testResults[totalTests]=6
		echo "Test result=Fail(bbservice crash, check bbservice_stress_core)" >> $testResultFile
		renameCoreDump "bbservice_stress_core"
		if [ "$coreDump" -eq 1 ]; then
		    local bbserviceCallStack="bbservice_stress_crash_error.txt"
	        analyzeCoreDump "${LinuxDbgBinDir}/bbservice" "bbservice_stress_core" "$bbserviceCallStack"
	        echo "<p>Test result=Fail(bbservice crash,check <a class="error" href="\"$bbserviceCallStack\"">log</a>)</p>" >> $testResultHtml
	    else
	        echo "<p>Test result=Fail(bbservice crash,core dump miss)</p>" >> $testResultHtml
	    fi
	else
		testResults[totalTests]=6
		echo "Test result=Fail(unexpected)" >> $testResultFile
		echo "<p>Test result=Fail(unexpected)</p>" >> $testResultHtml
	fi

	# Stop old daemon
	clean_up_all

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: runBbsigStressAuth
# Description: 
#	bbservice/bbsig stress authentication test
# Parameter: none
# Return: 
#	testResult is 0 if pass; 3 fail
function runBbsigStressAuth() {
	
	echo "SC bbservice/bbsig stress authentication test ..." >> $testDetailLog
	
	local testMap="stress authentication signal"

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase($testMap)"
	echo "Test case=$testCase($testMap)">> $testResultFile
    echo "<p>Test case=$testCase($testMap)</p>">> $testResultHtml
    
	# Stop old daemon
	clean_up_all

	local wkName="auth.signals"
	echo "bbsig stress test well-known name is $wkName"

	local serviceLog="${testDetailDir}${scriptName}_${testCase}_auth_bbservice.log"

	# Launch bbservice
	launchProcess "bbservice" $wkName $serviceLog "tcp" $STRESS_TEST 1 ""

	sleep 2
	
	# Launch bbsig 
	local bbsigLog="${testDetailDir}${scriptName}_${testCase}_auth_bbsig.log"
	
	launchProcess "bbsig" $wkName $bbsigLog "tcp" $STRESS_TEST 10 "-d -s -i 1 -ek SRP"

	# wait 5 min 
	sleep 300

	# Check bbsig or bbservice still live
	checkProcessCount "bbservice" 1
	local bbserviceLive=$processCount
	echo "After authentication test bbservice count $bbserviceLive"

	checkProcessCount "bbsig" 1
	local bbsigLive=$processCount
	echo "After authentication test bbsig count $bbsigLive"

	# Both bbsig and bbservice should be alive
	if [ "$bbserviceLive" -eq 1 -a "$bbsigLive" -eq 1 ]; then
		testResults[totalTests]=0
		echo "Test result=Pass" >> $testResultFile
		echo "<p>Test result=Pass</p>" >> $testResultHtml
	elif [ "$bbsigLive" -eq 0 ]; then
		testResults[totalTests]=6
		echo "Test result=Fail(bbsig crash,check bbsig_auth_core)" >> $testResultFile
		renameCoreDump "bbsig_auth_core"
		if [ "$coreDump" -eq 1 ]; then        
	        local bbsigAuthCallStack="bbsig_auth_crash_error.txt"
	        analyzeCoreDump "${LinuxDbgBinDir}/bbsig" "bbsig_auth_core" "$bbsigAuthCallStack"
	        echo "<p>Test result=Fail(bbsig crash,check <a class="error" href="\"$bbsigAuthCallStack\"">log</a>)</p>" >> $testResultHtml
	    else
	        echo "<p>Test result=Fail(bbsig crash,core dump unavailable)</p>" >> $testResultHtml
	    fi
	elif [ "$bbserviceLive" -eq 0 ]; then
		testResults[totalTests]=6
		echo "Test result=Fail(bbservice crash,check bbservice_auth_core)" >> $testResultFile
		renameCoreDump "bbservice_auth_core"
		if [ "$coreDump" -eq 1 ]; then
		    local bbserviceAuthCallStack="bbservice_auth_crash_error.txt"
	        analyzeCoreDump "${LinuxDbgBinDir}/bbservice" "bbservice_auth_core" "$bbserviceAuthCallStack"
	        echo "<p>Test result=Fail(bbservice crash,check <a class="error" href="\"$bbserviceAuthCallStack\"">log</a>)</p>" >> $testResultHtml  
	    else
	        echo "<p>Test result=Fail(bbservice crash,core dump unavailable)</p>" >> $testResultHtml      
	    fi
	else
		testResults[totalTests]=6
		echo "Test result=Fail(unexpected)" >> $testResultFile
		echo "<p>Test result=Fail(unexpected)</p>" >> $testResultHtml
	fi

	# Stop old daemon
	clean_up_all

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: runBastress2
# Description: 
#	bastress2 test
# Parameter: 
#   transport - tcp or udp
# Return: 
#	testResult is 0 if pass; 3 fail
function runBastress2() {
	local transport=$1
	echo "SC bastress2 stress test over $transport ..." >> $testDetailLog
	
	local testMap="SC bastress2 $transport"

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase($testMap)"
	echo "Test case=$testCase($testMap)">> $testResultFile
    echo "<p>Test case=$testCase($testMap)</p>">> $testResultHtml
    
	# Stop old daemon
	clean_up_all

	local wkName="com.bastress2.${transport}"
	echo "bastress2 stress test well-known name is $wkName"

	local serviceLog="${testDetailDir}${scriptName}_${testCase}_bastress2_service_${transport}.log"

	# Launch bastress2 service mode 
	launchProcess "bastress2" "" $serviceLog "tcp" $STRESS_TEST 1 "-os -s -$transport -n $wkName"

	sleep 2
	
	# Launch bastress2 client mode
	local clientLog="${testDetailDir}${scriptName}_${testCase}_bastress2_client_${transport}.log"
	
	launchProcess "bastress2" "" $clientLog "tcp" $STRESS_TEST 1 "-oc -s -$transport -n $wkName"

	# wait 11 min so both service and client complete
	sleep 660

    # Check service log
    local service_pass=0
    local SERVICE_OK="bastress2 exiting after timed completion"
    service_pass=`grep "$SERVICE_OK" $serviceLog |wc -l`
    
    # Check client log
    local client_pass=0
    local CLIENT_OK="PASSED"
    client_pass=`grep "$CLIENT_OK" $clientLog |wc -l`
    
	# Both bastress2 service and client should pass
	if [ "$service_pass" -eq 1 -a "$client_pass" -eq 1 ]; then
		testResults[totalTests]=0
		echo "Test result=Pass" >> $testResultFile
		echo "<p>Test result=Pass</p>" >> $testResultHtml
	else
	    # Something wrong
    	testResults[totalTests]=6
    	
    	# Check if any core dump exists
    	coreDump=0
	    renameCoreDump "bastress2_${transport}_core"
	    
	    if [ "$coreDump" -eq 1 ]; then
	        local bastress2CrashLog="bastress2_${transport}_crash_error.txt"
	        analyzeCoreDump "${LinuxDbgBinDir}/bastress2" "bastress2_${transport}_core" "$bastress2CrashLog"
	        
	        if [ "$service_pass" -eq 0 ]; then        	            
		        echo "Test result=Fail(service crash,check bastress2_${transport}_core)" >> $testResultFile
		        echo "<p>Test result=Fail(service crash,check <a class="error" href="\"$bastress2CrashLog\"">log</a>)</p>" >> $testResultHtml
		    else
		        echo "Test result=Fail(client crash,check bastress2_${transport}_core)" >> $testResultFile
		        echo "<p>Test result=Fail(client crash,check <a class="error" href="\"$bastress2CrashLog\"">log</a>)</p>" >> $testResultHtml
		    fi
		else
		    if [ "$service_pass" -eq 0 ]; then   
		        local serviceErrorLog="${scriptName}_${testCase}_bastress2_service_${transport}_error.txt"
		        mv $serviceLog $serviceErrorLog
		        echo "Test result=Fail(service error log)" >> $testResultFile
		        echo "<p>Test result=Fail(service <a class="error" href="\"$serviceErrorLog\"">log</a>)</p>" >> $testResultHtml
		    else
		        local clientErrorLog="${scriptName}_${testCase}_bastress2_client_${transport}_error.txt"
		        mv $clientLog $clientErrorLog
		        echo "Test result=Fail(client error log)" >> $testResultFile
		        echo "<p>Test result=Fail(client <a class="error" href="\"$clientErrorLog\"">log</a>))</p>" >> $testResultHtml
		    fi
        fi
	fi

	# Stop old daemon
	clean_up_all

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: runBbjoinStress
# Description: 
#	bbjoin stress test
# Parameter: none
# Return: 
#	testResult is 0 if pass; 6 fail
function runBbjoinStress() {
	
	echo "SC bbjoin stress test ..." >> $testDetailLog
	
	local testMap="SC bbjoin stress"

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase($testMap)"
	echo "Test case=$testCase($testMap)">> $testResultFile
    echo "<p>Test case=$testCase($testMap)</p>">> $testResultHtml
    
	# Stop old daemon
	clean_up_all

	local bbjoin1Log="${testDetailDir}${scriptName}_${testCase}_bbjoin1.log"
	local bbjoin2Log="${testDetailDir}${scriptName}_${testCase}_bbjoin2.log"
	local bbjoin3Log="${testDetailDir}${scriptName}_${testCase}_bbjoin3.log"
	local bbjoin4Log="${testDetailDir}${scriptName}_${testCase}_bbjoin4.log"

	# Launch 1st bbjoin
	launchProcess "bbjoin" "" $bbjoin1Log "tcp" $STRESS_TEST 1 "-n gov.a -f gov -qnoc -p -t -s -dj 1000 -dl 800"

	# Launch 2nd bbjoin
	launchProcess "bbjoin" "" $bbjoin2Log "tcp" $STRESS_TEST 1 "-n gov.b -f gov -qnoc -p -t -s -dj 800 -dl 600"

	# Launch 3rd bbjoin
	launchProcess "bbjoin" "" $bbjoin3Log "tcp" $STRESS_TEST 1 "-n gov.c -f gov -qnoc -p -t -s -dj 600 -dl 400"

	# Launch 4th bbjoin
	launchProcess "bbjoin" "" $bbjoin4Log "tcp" $STRESS_TEST 1 "-n gov.d -f gov -qnoc -p -t -s -dj 400 -dl 200"

	# wait 5 min 
	sleep 300

	# Check all 4 bbjoin still live
	checkProcessCount "bbjoin" 4
	local bbjoinsLive=$processCount
	echo "bbjoin count $bbjoinsLive"

	# Both bastress2 service and client should be alive
	if [ "$bbjoinsLive" -eq 4 ]; then
		testResults[totalTests]=0
		echo "Test result=Pass" >> $testResultFile
		echo "<p>Test result=Pass</p>" >> $testResultHtml
	else
		testResults[totalTests]=6
		echo "Test result=Fail(bbjoin crash,check bbjoin_core)" >> $testResultFile
		renameCoreDump "bbjoin_core"
		if [ "$coreDump" -eq 1 ]; then
	        analyzeCoreDump "${LinuxDbgBinDir}/bbjoin" "bbjoin_core" "bbjoin_stress_crash_error.txt"
	        echo "<p>Test result=Fail(bbjoin crash,check <a class="error" href="\"bbjoin_stress_crash_error.txt\"">log</a>)</p>" >> $testResultHtml
	    else
	        echo "<p>Test result=Fail(bbjoin crash,core dump unavailable)</p>" >> $testResultHtml
	    fi
	fi

	# Stop old daemon
	clean_up_all

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: basicCSample
# Description: 
#	bastress2 test
# Parameter: 
#	testVariant   - debug or release
# Return: 
#	testResult is 0 if pass; 6 fail
function basicCSample() {
	local testVariant=$1

	echo "Linux C sample ..." >> $testDetailLog
	
	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase($testVariant C sample)"
	echo "Test case=$testCase($testVariant C sample)" >> $testResultFile
	echo "<p>Test case=$testCase($testVariant C sample)</p>" >> $testResultHtml

	# Stop old processes
	clean_up_all

	local serviceLog="${testDetailDir}${scriptName}_${testCase}_basic_c_service_${testVariant}.log"

	# Launch basic_c_service
	launchProcess "basic_c_service" "" $serviceLog "tcp" $BUNDLED_TEST 1 "$testVariant"

	sleep 2
	
	# Launch basic_c_client
	local clientLog="${testDetailDir}${scriptName}_${testCase}_basic_c_client_${testVariant}.log"
	
	launchProcess "basic_c_client" "" $clientLog "tcp" $BUNDLED_TEST 1 "$testVariant"

	# wait 30 seconds
	sleep 30

	# Check basic_c_service still live
	checkProcessCount "basic_c_service" 1
	local basicCServiceLive=$processCount
	echo "basic_c_service count $basicCServiceLive"

	# Check basic_c_client discovery twice for all(udp and tcp)
	local DISCOVERY_KEY="found_advertised_name(name=org.alljoyn.Bus.sample, prefix=org.alljoyn.Bus.sample)"
	logHasKeysExactTimes $clientLog "${DISCOVERY_KEY}" 2
	discoveryResult=$matchResult

	# Check basic_c_client joinSession twice for all(udp and tcp)
	local JOIN_KEY="alljoyn_busattachment_joinsession SUCCESS"
	logHasKeysExactTimes $clientLog "${JOIN_KEY}" 2
	joinResult=$matchResult

	local METHOD_KEY="Hello World"
	decideLogWithKeys $clientLog "${METHOD_KEY}"
	methodResult=$testResult

	local EXIT_KEY="basic client exiting with status 0 "
	decideLogWithKeys $clientLog "${EXIT_KEY}"
	exitResult=$testResult

	# basic_c_service should be alive
	if [ "$basicCServiceLive" -eq 1 ]; then
		if [ "$discoveryResult" -eq 0 -a "$joinResult" -eq 0 -a "$methodResult" -eq 0 -a "$exitResult" -eq 0 ]; then
			testResults[totalTests]=0
			echo "Test result=Pass" >> $testResultFile
			echo "<p>Test result=Pass</p>" >> $testResultHtml
		else 
    		local clientError="${testDetailDir}${scriptName}_${testCase}_basic_c_client_${testVariant}_error.txt"
    		mv $clientLog $clientError
    		
		    if [ "$discoveryResult" -ne 0 ]; then
			    testResults[totalTests]=6
			    echo "Test result=Fail(discovery)" >> $testResultFile
			    echo "<p>Test result=Fail(<a class="error" href="\"$clientError\"">discovery</a>)</p>" >> $testResultHtml
		    elif [ "$joinResult" -ne 0 ]; then
			    testResults[totalTests]=6
			    echo "Test result=Fail(joinSession)" >> $testResultFile
			    echo "<p>Test result=Fail(<a class="error" href="\"$clientError\"">joinSession</a>)</p>" >> $testResultHtml
		    elif [ "$methodResult" -ne 0 ]; then
			    testResults[totalTests]=6
			    echo "Test result=Fail(method return)" >> $testResultFile
			    echo "<p>Test result=Fail(<a class="error" href="\"$clientError\"">method return</a>)</p>" >> $testResultHtml
		    else
			    testResults[totalTests]=6
			    echo "Test result=Fail(exit non-zero)" >> $testResultFile
			    echo "<p>Test result=Fail(<a class="error" href="\"$clientError\"">exit non-zero</a>)</p>" >> $testResultHtml
		    fi
		fi
	else
		testResults[totalTests]=6
		echo "Test result=Fail(basic_c_service crash)" >> $testResultFile
		echo "<p>Test result=Fail(basic_c_service crash)</p>" >> $testResultHtml
	fi

	# Stop old daemon
	clean_up_all

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: runCSamples
# Description: run C samples
# Parameter: none
# Return: none
function runCSamples() {
	echo "Run C samples..." >> $testDetailLog

	# C sample
	if [ -d "$cRelSampleDir" ]; then
		CRELSERVICE="${cRelSampleDir}/basic_c_service"
		CRELCLIENT="${cRelSampleDir}/basic_c_client"

		if [ -e "$CRELSERVICE" -a -e "$CRELCLIENT" ]; then
			$verbose && echo "Release c sample basic_c_service and basic_c_client exist"

			# Run C release Sample - basic_c_service and basic_c_client
			basicCSample "release"

		else
			echo "Release c sample basic_c_service or basic_c_client does NOT exist!"
		fi
	fi

	if [ -d "$cDbgSampleDir" ]; then
		CDBGSERVICE="${cDbgSampleDir}/basic_c_service"
		CDBGCLIENT="${cDbgSampleDir}/basic_c_client"

		if [ -e "$CDBGSERVICE" -a -e "$CDBGCLIENT" ]; then
			$verbose && echo "Debug c sample basic_c_service and basic_c_client exist"

			# Run C debug Sample - basic_c_service and basic_c_client
			basicCSample "debug"
		else
			echo "Debug c sample basic_c_service or basic_c_client does NOT exist!"
		fi
	fi

}

# Function name: runMultipointSessions
# Description: run multipoint session tests with 2+ clients
# Parameter: none
# Return: 
#	testResult is 0 if pass; 3 fail
function runMultipointSessions() {
	echo "Run multipoint session tests..." >> $testDetailLog

	# Two remote clients
	TwoRemoteClients

}

# Function name: runSCMessaging
# Description: sc core platform independent end to end messaging tests
# Parameter: none
# Return: none
function runSCMessaging() {
	echo "Run sc end to end messaging tests..." >> $testDetailLog

	# Introspection tests w/o pre-installed daemon
	runSCIntrospection 0
	
	runSCIntrospection 1

	# Asynchronous method calls w/o pre-installed daemon
	runSCAsyncCall 0

	runSCAsyncCall 1
	
	# Synchronous and Asynchronous method calls w/o pre-installed daemon
	runSCSyncAsyncMix 0

	runSCSyncAsyncMix 1

	# shared keystore
	# 1st LOGON test may fail because of new keystore
	#runSharedKeyStore 0

	#runSharedKeyStore 1
}
# Function name: runSCIndependent
# Description: standard client core platform independent tests
# Parameter: none
# Return: none
function runSCIndependent() {
	echo "Run standard client core platform independent tests..." >> $testDetailLog

	#End to end messaging and encryption tests
	runSCMessaging

}
# Function name: runSCStress
# Description: standard client stress tests
# Parameter: none
# Return: none
function runSCStress() {

	if [ -d "$LinuxDbgBinDir" ]; then
		# turn on core dump
		ulimit -c unlimited

		# Run bbservice/bbsig stress
		runBbsigStress

		# Run bbservice/bbsig stress with authentication
		runBbsigStressAuth
		
		# Run bbstress2 test over tcp
		runBastress2 "t"
		
		# Run bbstress2 test over udp
		runBastress2 "u"

		# Run 4 bbjoin stress test
		runBbjoinStress
	else
		echo "$LinuxDbgBinDir does NOT exist!"
	fi

}
# Function name: PdSlsTest
# Description: run policy db sessionless signal related tests
# Parameter: 
#	pd_config - policy db daemon config file
#	testDesc - test case number and description
# Return: 
#	testResult is 0 if pass; 6 fail
function PdSlsTest() {
	local pd_config=$1
	local testDesc=$2

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase($testDesc)"
	echo "Test case=$testCase($testDesc)">> $testResultFile
    echo "<p>Test case=$testCase($testDesc)</p>">> $testResultHtml

	# Config file must exist and not empty
	if [ -e "$pd_config" -a -s "$pd_config" ]; then
			
		# Launch standard-alone daemon
		local daemonLog="policy_db_daemon_${testCase}.log"
		launchProcess "alljoyn-daemon" "$pd_config" $daemonLog "" $POLICYDB_TEST 1 ""

		sleep 1

		echo "Launching AboutService with special port"
		# Launch AboutService
		local serviceLog="policy_about_service_${testCase}.log"
		launchProcess "AboutService" "" $serviceLog "" $POLICYDB_TEST 1 ""

		sleep 1
		
		echo "Launching AboutClient"
		# Launch AboutClient
		local deniedClientLog="deny_aboutclient_${testCase}.log"
		launchProcess "AboutClient" "" $deniedClientLog "" $POLICYDB_TEST 1 ""
	
		# AboutClient should NOT receive any announcement
		sleep 60

		# Stop old daemon
		clean_up_all

		# Cleanup
		killProcess "AboutService"

		killProcess "AboutClient"

		# Check aboutClient log has no announcement data with version
		decideUnitTest $denyClientLog "$ANY_ANNOUNCEMENT"
		local denyError=$testResult
	
		if [  "$denyError" -ne 0 ]; then		
			testResults[totalTests]=0
			echo "Test result=Pass" >> $testResultFile
			echo "<p>Test result=Pass</p>" >> $testResultHtml
		else
		    local deniedClientError="deny_aboutclient_${testCase}_error.txt"
		    mv $deniedClientLog $deniedClientError
			testResults[totalTests]=6
			echo "Test result=Fail(Announcement received)" >> $testResultFile
			echo "<p>Test result=Fail(<a class="error" href="\"$deniedClientError\"">Announcement</a> received)</p>" >> $testResultHtml
		fi

	else
		echo "Not exist or empty $pd_config , test block!"
		testResults[totalTests]=3
		echo "Test result=Block(Config file)" >> $testResultFile
		echo "<p>Test result=Block(Config file)</p>" >> $testResultHtml
	fi

	# Increse test count
	totalTests=$(($totalTests + 1))	
}
# Function name: TestSessionlessSignal
# Description: run policy db receive_member related tests
# Parameter: none
# Return: none
function TestSessionlessSignal() {
	echo "Run policy db sls tests..." >> $testDetailLog

	# copy about library to run test
	checkAboutSamples "${POLICYDB_ABOUT_BIN_DIR}" "${POLICYDB_ABOUT_LIB_DIR}" "${POLICYDB_DBG_LIB_DIR}"

	if [ "$aboutSampleReady" -eq 0 ]; then
		# Default receive_member test
		local pdConfigFile="${POLICY_DB_ROOT}/${SLS_DIR}/default_sls_deny.conf"
		PdSlsTest $pdConfigFile "#173-Policy default sls" 0
	fi
}

# Function name: extractNames
# Description: 
#	Parse config file and extract allowed/denied names
# Parameter: 
#	pd_config - policy db daemon config file
#	allowKeys - What allow rule starts
#	denyKeys  - What deny rule starts	
# Return: 
#	extractStatus is 0 if file OK(allowedName and deniedName are set)
#   extractStatus is 1 if file is invalid
# Notes:
# Assume file contains one ploicy block with at most one allow rule and one deny rule
#	<policy context="mandatory">
#		<allow own="org.a"/>
#  		<deny own="gov.a"/>	
#	</policy>
function extractNames() {
	local pd_config=$1
	local allowKeys=$2
	local denyKeys=$3
	echo "Extract allowed/denied info from $pd_config ..." >> $testDetailLog
	
	extractStatus=1
	allowedName=""
	deniedName=""

	local policyBlocks=`grep "<policy" $pd_config |wc -l`

	if [ "$policyBlocks" -eq 1 ]; then
		# Make sure allow rule <= 1
  	 	allowedName=`grep "$allowKeys" $pd_config | awk -F"\"" '{print $2}'`
		local allowNameCount=`echo "$allowedName" |wc -w`
		deniedName=`grep "$denyKeys" $pd_config | awk -F"\"" '{print $2}'`
		local denyNameCount=`echo "$deniedName" |wc -w`

		echo "Parsed allowed name: $allowedName Denied name: $deniedName "

		if [ "$allowNameCount" -gt 1 ]; then
			echo "More than one allowed names $allowName !"
		elif [ "$denyNameCount" -gt 1 ]; then
			echo "More than one denied names $deniedName !"
		elif [ "$allowNameCount" -eq 0 -a "$denyNameCount" -eq 0 ]; then
			echo "No allowed name and denied name are set !"
		elif [ "$allowedName" == "$deniedName" ]; then
			# We can't tell which one is ahead
			echo "Allowed name and denied name should NOT be same !"
		else
			echo "Correct policy block"
			extractStatus=0
		fi
	else
		echo "More than one policy blocks $policyBlocks !"
	fi
	
}

# Function name: generateRandomName
# Description: Generate a random name to advertise
# Parameter: 
#	namePrefix - name prefix
# Return: 
#	randomName is generated
function generateRandomName() {
	local namePrefix=$1

	echo "Generate name with prefix ${namePrefix}, any valid names for *"

	if [ "$namePrefix" == "*" ]; then
		randomName="dof.abc43"
	else
		randomName="${namePrefix}.cd54"
	fi
}

# Function name: PdNameTest
# Description: run policy db name ownership related tests
# Parameter: 
#	pd_config - policy db daemon config file
#	testDesc - test case number and description
#	isPrefix - 1 for own_prefix tests; 0 for own tests
# Return: 
#	testResult is 0 if pass; 6 fail
function PdNameTest() {
	local pd_config=$1
	local testDesc=$2
	local isPrefix=$3

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase($testDesc)"
	echo "Test case=$testCase($testDesc)">> $testResultFile
    echo "<p>Test case=$testCase($testDesc)</p>">> $testResultHtml

	# Config file must exist and not empty
	if [ -e "$pd_config" -a -s "$pd_config" ]; then

		# Extract allowed/denied names from config file
		extractNames $pd_config "<allow own" "<deny own"

		# Run test iff policy db config file is valid
		if [ "$extractStatus" -eq 0 ]; then
			
			# Launch standard-alone daemon
			local daemonLog="policy_db_daemon_${testCase}.log"
			launchProcess "alljoyn-daemon" "$pd_config" $daemonLog "" $POLICYDB_TEST 1 ""

			sleep 1

			if [ "$allowedName" == "*" -o "$isPrefix" -eq 1 ]; then
				echo "Allow everything with prefix, randomly generate a name"
				generateRandomName "$allowedName"

				allowedName="$randomName"
			fi

			echo "Launching bbservice with $allowedName"
			# Launch bbservice with allowed name
			local allowLog="allow_bbservice_${testCase}.log"
			launchProcess "bbservice" $allowedName $allowLog "" $POLICYDB_TEST 1 ""

			sleep 2

			if [ "$deniedName" == "*" -o "$isPrefix" -eq 1 ]; then
				echo "Deny everything with prefix, randomly generate a name"
				generateRandomName "$deniedName"

				deniedName="$randomName"
			fi
			
			echo "Launching bbservice with $deniedName"
			# Launch bbservice with denied name
			local denyLog="deny_bbservice_${testCase}.log"
			launchProcess "bbservice" $deniedName $denyLog "" $POLICYDB_TEST 1 ""

			sleep 10

			# Stop old daemon
			clean_up_all

			# Check allow log has no error message
			local requestNameFailure="RequestName returned ERROR|RequestName.*0x9032|RequestName.*failed"
			decideUnitTest $allowLog "$requestNameFailure"
			local allowError=$testResult

			decideUnitTest $denyLog "$requestNameFailure"
			local denyError=$testResult

			if [ "$allowError" -ne 0 -a "$denyError" -eq 0 ]; then		
				testResults[totalTests]=0
				echo "Test result=Pass" >> $testResultFile
				echo "<p>Test result=Pass</p>" >> $testResultHtml
			elif [ "$allowError" -eq 0 ]; then
			    local allowError="allow_bbservice_${testCase}_error.txt"
			    mv $allowLog $allowError
				testResults[totalTests]=6
				echo "Test result=Fail(Allow rule)" >> $testResultFile
				echo "<p>Test result=Fail(<a class="error" href="\"$allowError\"">Allow rule</a>)</p>" >> $testResultHtml
			else
			    local denyError="deny_bbservice_${testCase}_error.txt"
			    mv $denyLog $denyError
				testResults[totalTests]=6
				echo "Test result=Fail(Deny rule)" >> $testResultFile
				echo "<p>Test result=Fail(<a class="error" href="\"$denyError\"">Deny rule</a>)</p>" >> $testResultHtml
			fi
		else
			testResults[totalTests]=3
			echo "Test result=Block(Config file ${pd_config} parse error)" >> $testResultFile
			echo "<p>Test result=Block(Config file ${pd_config} parse error)</p>" >> $testResultHtml
		fi

	else
		echo "Not exist or empty $pd_config , test block!"
		testResults[totalTests]=3
		echo "Test result=Block(Config file ${pd_config} miss)" >> $testResultFile
		echo "<p>Test result=Block(Config file ${pd_config} miss)</p>" >> $testResultHtml
	fi

	# Stop old daemon
	clean_up_all

	# Increse test count
	totalTests=$(($totalTests + 1))	
}
# Function name: TestName
# Description: run policy db name ownership related tests
# Parameter: none
# Return: none
function TestName() {
	echo "Run policy db name ownership tests..." >> $testDetailLog

	# Default name ownership test
	local pdConfigFile="${POLICY_DB_ROOT}/${NAME_DIR}/name_own_default.conf"
	PdNameTest $pdConfigFile "#13-Policy default name" 0

	# Mandatory name ownership test
	pdConfigFile="${POLICY_DB_ROOT}/${NAME_DIR}/name_own_mandatory.conf"
	PdNameTest $pdConfigFile "#14-Policy mandatory name" 0

	# Group name ownership test
	#pdConfigFile="${POLICY_DB_ROOT}/${NAME_DIR}/name_own_group.conf"
	#PdNameTest $pdConfigFile "#15-Policy group name" 0

	# User name ownership test
	#pdConfigFile="${POLICY_DB_ROOT}/${NAME_DIR}/name_own_user.conf"
	#PdNameTest $pdConfigFile "#16-Policy user name" 0

	# Default wildcard name ownership test
	pdConfigFile="${POLICY_DB_ROOT}/${NAME_DIR}/wildcard_name_default.conf"
	PdNameTest $pdConfigFile "#17-Policy default name wildcard" 0

	# Mandatory wildcard name ownership test
	pdConfigFile="${POLICY_DB_ROOT}/${NAME_DIR}/wildcard_name_mandatory.conf"
	PdNameTest $pdConfigFile "#18-Policy mandatory name wildcard" 0

	# Group wildcard name ownership test
	#pdConfigFile="${POLICY_DB_ROOT}/${NAME_DIR}/wildcard_name_group.conf"
	#PdNameTest $pdConfigFile "#19-Policy group name wildcard" 0

	# User wildcard name ownership test
	#pdConfigFile="${POLICY_DB_ROOT}/${NAME_DIR}/wildcard_name_user.conf"
	#PdNameTest $pdConfigFile "#20-Policy user name wildcard" 0

	# Default name prefix test
	pdConfigFile="${POLICY_DB_ROOT}/${NAME_PREFIX_DIR}/name_prefix_default.conf"
	PdNameTest $pdConfigFile "#21-Policy default name prefix" 1

	# Mandatory name prefix test
	pdConfigFile="${POLICY_DB_ROOT}/${NAME_PREFIX_DIR}/name_prefix_mandatory.conf"
	PdNameTest $pdConfigFile "#22-Policy mandatory name prefix" 1

	# Group name prefix test
	#pdConfigFile="${POLICY_DB_ROOT}/${NAME_PREFIX_DIR}/name_prefix_group.conf"
	#PdNameTest $pdConfigFile "#23-Policy group name prefix" 1

	# User name prefix test
	#pdConfigFile="${POLICY_DB_ROOT}/${NAME_PREFIX_DIR}/name_prefix_user.conf"
	#PdNameTest $pdConfigFile "#24-Policy user name prefix" 1

	# Default name prefix wildcard test
	pdConfigFile="${POLICY_DB_ROOT}/${NAME_PREFIX_DIR}/wildcard_name_prefix_default.conf"
	PdNameTest $pdConfigFile "#25-Policy default name prefix wildcard" 1

	# Mandatory name prefix wildcard test
	pdConfigFile="${POLICY_DB_ROOT}/${NAME_PREFIX_DIR}/wildcard_name_prefix_mandatory.conf"
	PdNameTest $pdConfigFile "#26-Policy mandatory name prefix wildcard" 1

	# Group name prefix wildcard test
	#pdConfigFile="${POLICY_DB_ROOT}/${NAME_PREFIX_DIR}/wildcard_name_prefix_group.conf"
	#PdNameTest $pdConfigFile "#27-Policy group name prefix wildcard" 1

	# User name prefix wildcard test
	#pdConfigFile="${POLICY_DB_ROOT}/${NAME_PREFIX_DIR}/wildcard_name_prefix_user.conf"
	#PdNameTest $pdConfigFile "#28-Policy user name prefix wildcard" 1
}
# Function name: PdSendDestTest
# Description: run policy db send destination related tests
# Parameter: 
#	pd_config - policy db daemon config file
#	testDesc - test case number and description
# Return: 
#	testResult is 0 if pass; 6 fail
function PdSendDestTest() {
	local pd_config=$1
	local testDesc=$2

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase($testDesc)"
	echo "Test case=$testCase($testDesc)">> $testResultFile
    echo "<p>Test case=$testCase($testDesc)</p>">> $testResultHtml

	# Config file must exist and not empty
	if [ -e "$pd_config" -a -s "$pd_config" ]; then

		# Extract allowed/denied names from config file
		extractNames $pd_config "<allow send_destination" "<deny send_destination"

		# Run test iff policy db config file is valid
		if [ "$extractStatus" -eq 0 ]; then
			
			# Launch standard-alone daemon
			local daemonLog="policy_db_daemon_${testCase}.log"
			launchProcess "alljoyn-daemon" "$pd_config" $daemonLog "" $POLICYDB_TEST 1 ""

			sleep 1

			if [ "$allowedName" == "*" ]; then
				echo "Allow send to anyone, randomly generate a name"
				generateRandomName "$allowedName"

				allowedName="$randomName"
			fi

			if [ "$deniedName" == "*" ]; then
				echo "Deny send to anyone, randomly generate a name"
				generateRandomName "$deniedName"

				deniedName="$randomName"
			fi

			echo "Launching bbservice with allowed name $allowedName"
			# Launch bbservice with allowed name
			local allowServiceLog="allow_bbservice_${testCase}.log"
			launchProcess "bbservice" $allowedName $allowServiceLog "" $POLICYDB_TEST 1 ""

			sleep 1

			echo "Launching bbclient with allowed name $allowedName"
			# Launch bbclient with allowed name
			local allowClientLog="allow_bbclient_${testCase}.log"
			launchProcess "bbclient" $allowedName $allowClientLog "" $POLICYDB_TEST 1 ""
	
			# Wait bbclient to complete
			sleep 30
		
			echo "Launching bbservice with denied name $deniedName"
			# Launch bbservice with denied name
			local denyServiceLog="deny_bbservice_${testCase}.log"
			launchProcess "bbservice" $deniedName $denyServiceLog "" $POLICYDB_TEST 1 ""

			sleep 1

			echo "Launching bbclient with denied name $deniedName"
			# Launch bbclient with denied name
			local deniedClientLog="deny_bbclient_${testCase}.log"
			launchProcess "bbclient" $deniedName $deniedClientLog "" $POLICYDB_TEST 1 ""
	
			# Wait bbclient to timeout
			sleep 60

			# Stop old daemon
			clean_up_all

			# Check allow log has no error message
			decideUnitTest $allowClientLog "$BBCLIENTCOMPLETE"
			local allowError=$testResult

			decideUnitTest $denyClientLog "$BBCLIENTCOMPLETE"
			local denyError=$testResult

			if [ "$allowError" -eq 0 -a "$denyError" -ne 0 ]; then		
				testResults[totalTests]=0
				echo "Test result=Pass" >> $testResultFile
				echo "<p>Test result=Pass</p>" >> $testResultHtml
			elif [ "$allowError" -ne 0 ]; then
			    local allowClientError="allow_bbclient_${testCase}_error.txt"
			    mv $allowClientLog $allowClientError
				testResults[totalTests]=6
				echo "Test result=Fail(Allow rule)" >> $testResultFile
				echo "<p>Test result=Fail(<a class="error" href="\"$allowClientError\"">Allow rule</a>)</p>" >> $testResultHtml
			else
			    local deniedClientError="deny_bbclient_${testCase}_error.txt"
			    mv $deniedClientLog $deniedClientError
				testResults[totalTests]=6
				echo "Test result=Fail(Deny rule)" >> $testResultFile
				echo "<p>Test result=Fail(<a class="error" href="\"$deniedClientError\"">Deny rule</a>)</p>" >> $testResultHtml
			fi
		else
			testResults[totalTests]=3
			echo "Test result=Block(Config file ${pd_config} parse error)" >> $testResultFile
			echo "<p>Test result=Block(Config file ${pd_config} parse error)</p>" >> $testResultHtml
		fi

	else
		echo "Not exist or empty $pd_config , test block!"
		testResults[totalTests]=3
		echo "Test result=Block(Config file ${pd_config} miss)" >> $testResultFile
		echo "<p>Test result=Block(Config file ${pd_config} miss)</p>" >> $testResultHtml
	fi

	# Stop old daemon
	clean_up_all

	# Increse test count
	totalTests=$(($totalTests + 1))	
}
# Function name: TestSendDest
# Description: run policy db send_destination related tests
# Parameter: none
# Return: none
function TestSendDest() {
	echo "Run policy db send_* tests..." >> $testDetailLog

	# Default send_destination test
	local pdConfigFile="${POLICY_DB_ROOT}/${SEND_DEST_DIR}/send_dest_default.conf"
	PdSendDestTest $pdConfigFile "#29-Policy default send destination"

	# Mandatory send_destination test
	local pdConfigFile="${POLICY_DB_ROOT}/${SEND_DEST_DIR}/send_dest_mandatory.conf"
	PdSendDestTest $pdConfigFile "#30-Policy mandatory send destination"

	# Group send_destination test
	#local pdConfigFile="${POLICY_DB_ROOT}/${SEND_DEST_DIR}/send_dest_group.conf"
	#PdSendDestTest $pdConfigFile "#31-Policy group send destination"

	# User send_destination test
	#local pdConfigFile="${POLICY_DB_ROOT}/${SEND_DEST_DIR}/send_dest_user.conf"
	#PdSendDestTest $pdConfigFile "#32-Policy user send destination"

	# Default send_destination wildcard test
	local pdConfigFile="${POLICY_DB_ROOT}/${SEND_DEST_DIR}/send_dest_wildcard_default.conf"
	PdSendDestTest $pdConfigFile "#33-Policy default send destination wildcard"

	# Mandatory send_destination wildcard test
	local pdConfigFile="${POLICY_DB_ROOT}/${SEND_DEST_DIR}/send_dest_wildcard_mandatory.conf"
	PdSendDestTest $pdConfigFile "#34-Policy mandatory send destination wildcard"

	# Group send_destination wildcard test
	#local pdConfigFile="${POLICY_DB_ROOT}/${SEND_DEST_DIR}/send_dest_wildcard_group.conf"
	#PdSendDestTest $pdConfigFile "#35-Policy group send destination wildcard"

	# User send_destination wildcard test
	#local pdConfigFile="${POLICY_DB_ROOT}/${SEND_DEST_DIR}/send_dest_wildcard_user.conf"
	#PdSendDestTest $pdConfigFile "#36-Policy user send destination wildcard"
}
# Function name: PdRecvSenderTest
# Description: run policy db receiver sender related tests
# Parameter: 
#	pd_config - policy db daemon config file
#	testDesc - test case number and description
# Return: 
#	testResult is 0 if pass; 6 fail
function PdRecvSenderTest() {
	local pd_config=$1
	local testDesc=$2

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase($testDesc)"
	echo "Test case=$testCase($testDesc)">> $testResultFile
    echo "<p>Test case=$testCase($testDesc)</p>">> $testResultHtml

	# Config file must exist and not empty
	if [ -e "$pd_config" -a -s "$pd_config" ]; then

		# Extract allowed/denied names from config file
		extractNames $pd_config "<allow receive_sender" "<deny receive_sender"

		# Run test iff policy db config file is valid
		if [ "$extractStatus" -eq 0 ]; then
			
			# Launch standard-alone daemon
			local daemonLog="policy_db_daemon_${testCase}.log"
			launchProcess "alljoyn-daemon" "$pd_config" $daemonLog "" $POLICYDB_TEST 1 ""

			sleep 1

			if [ "$allowedName" == "*" ]; then
				echo "Allow receive from anyone, randomly generate a name"
				generateRandomName "$allowedName"

				allowedName="$randomName"
			fi

			if [ "$deniedName" == "*" ]; then
				echo "Deny receive from anyone, randomly generate a name"
				generateRandomName "$deniedName"

				deniedName="$randomName"
			fi

			echo "Launching bbservice with allowed name $allowedName"
			# Launch bbservice with allowed name
			local allowServiceLog="allow_bbservice_${testCase}.log"
			launchProcess "bbservice" $allowedName $allowServiceLog "" $POLICYDB_TEST 1 ""

			sleep 1

			echo "Launching bbclient with allowed name $allowedName"
			# Launch bbclient with allowed name
			local allowClientLog="allow_bbclient_${testCase}.log"
			launchProcess "bbclient" $allowedName $allowClientLog "" $POLICYDB_TEST 1 ""
	
			# Wait bbclient to complete
			sleep 30
		
			echo "Launching bbservice with denied name $deniedName"
			# Launch bbservice with denied name
			local denyServiceLog="deny_bbservice_${testCase}.log"
			launchProcess "bbservice" $deniedName $denyServiceLog "" $POLICYDB_TEST 1 ""

			sleep 1

			echo "Launching bbclient with denied name $deniedName"
			# Launch bbclient with denied name
			local deniedClientLog="deny_bbclient_${testCase}.log"
			launchProcess "bbclient" $deniedName $deniedClientLog "" $POLICYDB_TEST 1 ""
	
			# Wait bbclient to timeout
			sleep 60

			# Stop old daemon
			clean_up_all

			# Check allow log has no error message
			decideUnitTest $allowClientLog "$BBCLIENTCOMPLETE"
			local allowError=$testResult

			decideUnitTest $denyClientLog "$BBCLIENTCOMPLETE"
			local denyError=$testResult

			if [ "$allowError" -eq 0 -a "$denyError" -ne 0 ]; then		
				testResults[totalTests]=0
				echo "Test result=Pass" >> $testResultFile
				echo "<p>Test result=Pass</p>" >> $testResultHtml
			elif [ "$allowError" -ne 0 ]; then
			    local allowClientError="allow_bbclient_${testCase}_error.txt"
			    mv $allowClientLog $allowClientError
				testResults[totalTests]=6
				echo "Test result=Fail(Allow rule)" >> $testResultFile
				echo "<p>Test result=Fail(<a class="error" href="\"$allowClientError\"">Allow rule</a>)</p>" >> $testResultHtml
			else
			    local deniedClientError="deny_bbclient_${testCase}_error.txt"
			    mv $deniedClientLog $deniedClientError
				testResults[totalTests]=6
				echo "Test result=Fail(Deny rule)" >> $testResultFile
				echo "<p>Test result=Fail(<a class="error" href="\"$deniedClientError\"">Deny rule</a>)</p>" >> $testResultHtml
			fi
		else
			testResults[totalTests]=3
			echo "Test result=Block(Config file ${pd_config} parse error)" >> $testResultFile
			echo "<p>Test result=Block(Config file ${pd_config} parse error)</p>" >> $testResultHtml
		fi

	else
		echo "Not exist or empty $pd_config , test block!"
		testResults[totalTests]=3
		echo "Test result=Block(Config file ${pd_config} miss)" >> $testResultFile
		echo "<p>Test result=Block(Config file ${pd_config} miss)</p>" >> $testResultHtml
	fi

	# Stop old daemon
	clean_up_all

	# Increse test count
	totalTests=$(($totalTests + 1))	
}
# Function name: TestRecvSender
# Description: run policy db receive_* related tests
# Parameter: none
# Return: none
function TestRecvSender() {
	echo "Run policy db send_* tests..." >> $testDetailLog

	# Mandatory send_destination test
	local pdConfigFile="${POLICY_DB_ROOT}/${RECV_SENDER_DIR}/recv_sender_mandatory.conf"
	PdRecvSenderTest $pdConfigFile "#37-Policy mandatory receive sender"

	# Default send_destination test
	local pdConfigFile="${POLICY_DB_ROOT}/${RECV_SENDER_DIR}/recv_sender_default.conf"
	PdRecvSenderTest $pdConfigFile "#38-Policy default receive sender"

	# Group send_destination test
	#local pdConfigFile="${POLICY_DB_ROOT}/${RECV_SENDER_DIR}/recv_sender_group.conf"
	#PdRecvSenderTest $pdConfigFile "#39-Policy group receive sender"

	# User send_destination test
	#local pdConfigFile="${POLICY_DB_ROOT}/${RECV_SENDER_DIR}/recv_sender_user.conf"
	#PdRecvSenderTest $pdConfigFile "#40-Policy user receive sender"

	# Default send_destination wildcard test
	local pdConfigFile="${POLICY_DB_ROOT}/${RECV_SENDER_DIR}/recv_sender_wildcard_default.conf"
	PdRecvSenderTest $pdConfigFile "#41-Policy default receive sender wildcard"

	# Mandatory send_destination wildcard test
	local pdConfigFile="${POLICY_DB_ROOT}/${RECV_SENDER_DIR}/recv_sender_wildcard_mandatory.conf"
	PdRecvSenderTest $pdConfigFile "#42-Policy mandatory receive sender wildcard"

	# Group send_destination wildcard test
	#local pdConfigFile="${POLICY_DB_ROOT}/${RECV_SENDER_DIR}/recv_sender_wildcard_group.conf"
	#PdRecvSenderTest $pdConfigFile "#43-Policy group receive sender wildcard"

	# User send_destination wildcard test
	#local pdConfigFile="${POLICY_DB_ROOT}/${RECV_SENDER_DIR}/recv_sender_wildcard_user.conf"
	#PdRecvSenderTest $pdConfigFile "#44-Policy user send destination wildcard"
}

# Function name: PdSendMemberTest
# Description: run policy db send_member related tests
# Parameter: 
#	pd_config - policy db daemon config file
#	testDesc - test case number and description
# Return: 
#	testResult is 0 if pass; 6 fail
function PdSendMemberTest() {
	local pd_config=$1
	local testDesc=$2

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase($testDesc)"
	echo "Test case=$testCase($testDesc)">> $testResultFile
    echo "<p>Test case=$testCase($testDesc)</p>">> $testResultHtml

	# Config file must exist and not empty
	if [ -e "$pd_config" -a -s "$pd_config" ]; then
			
		# Launch standard-alone daemon
		local daemonLog="policy_db_daemon_${testCase}.log"
		launchProcess "alljoyn-daemon" "$pd_config" $daemonLog "" $POLICYDB_TEST 1 ""

		sleep 1

		echo "Launching bbservice without name"
		# Launch bbservice with allowed name
		local serviceLog="bbservice_${testCase}.log"
		launchProcess "bbservice" "" $serviceLog "" $POLICYDB_TEST 1 ""

		sleep 1

		echo "Launching bbclient with my_ping"
		# Launch bbclient with allowed name
		local allowClientLog="allow_bbclient_${testCase}.log"
		launchProcess "bbclient" "" $allowClientLog "" $POLICYDB_TEST 1 ""
	
		# Wait bbclient to complete
		sleep 20
		

		echo "Launching bbclient with time_ping(delayed ping)"
		# Launch bbclient with denied name
		local deniedClientLog="deny_bbclient_${testCase}.log"
		launchProcess "bbclient" "" $deniedClientLog "" $POLICYDB_TEST 1 "-rt 10"
	
		# Wait bbclient to timeout
		sleep 40

		echo "Launching bbsig "
		# Launch bbsig
		local deniedSigLog="deny_bbsig_${testCase}.log"
		launchProcess "bbsig" "" $deniedSigLog "" $POLICYDB_TEST 1 "-c 1000"
	
		# Wait bbsig to complete sending 1000 signals
		sleep 40

		# Stop old daemon
		clean_up_all

		# Check allow log has no error message
		decideUnitTest $allowClientLog "$BBCLIENTCOMPLETE"
		local allowError=$testResult

		decideUnitTest $denyClientLog "$BBCLIENTCOMPLETE"
		local denyError=$testResult
	
		decideUnitTest $serviceLog "$RECEIVESIGNAL"
		local denySig=$testResult

		if [ "$allowError" -eq 0 -a "$denyError" -ne 0 -a "$denySig" -ne 0 ]; then		
			testResults[totalTests]=0
			echo "Test result=Pass" >> $testResultFile
			echo "<p>Test result=Pass</p>" >> $testResultHtml
		elif [ "$allowError" -ne 0 ]; then
    		local allowClientError="allow_bbclient_${testCase}_error.txt"
    		mv $allowClientLog $allowClientError
			testResults[totalTests]=6
			echo "Test result=Fail(Allow my_ping)" >> $testResultFile
			echo "<p>Test result=Fail(<a class="error" href="\"$allowClientError\"">Allow my_ping</a>)</p>" >> $testResultHtml
		elif [ "$denyError" -eq 0 ]; then
		    local deniedClientError="deny_bbclient_${testCase}_error.txt"
		    mv $deniedClientLog $deniedClientError
			testResults[totalTests]=6
			echo "Test result=Fail(Deny time_ping)" >> $testResultFile
			echo "<p>Test result=Fail(<a class="error" href="\"$deniedClientError\"">Deny my_ping</a>)</p>" >> $testResultHtml
		else
		    local serviceError="bbservice_${testCase}_error.txt"
		    mv $serviceLog $serviceError
			testResults[totalTests]=6
			echo "Test result=Fail(Deny my_signal)" >> $testResultFile
			echo "<p>Test result=Fail(<a class="error" href="\"$serviceError\"">Deny my_signal</a>)</p>" >> $testResultHtml
		fi

	else
		echo "Not exist or empty $pd_config , test block!"
		testResults[totalTests]=3
		echo "Test result=Block(Config file ${pd_config} miss)" >> $testResultFile
		echo "<p>Test result=Block(Config file ${pd_config} miss)</p>" >> $testResultHtml
	fi

	# Increse test count
	totalTests=$(($totalTests + 1))	
}
# Function name: TestSendMember
# Description: run policy db send_member related tests
# Parameter: none
# Return: none
function TestSendMember() {
	echo "Run policy db send_* tests..." >> $testDetailLog

	# Default send_member test
	local pdConfigFile="${POLICY_DB_ROOT}/${SEND_MEMBER_DIR}/send_member_default.conf"
	PdSendMemberTest $pdConfigFile "#61-Policy default send member"

	# Mandatory send_member test
	local pdConfigFile="${POLICY_DB_ROOT}/${SEND_MEMBER_DIR}/send_member_mandatory.conf"
	PdSendMemberTest $pdConfigFile "#62-Policy mandatory send member"

	# Group send_member test
	#local pdConfigFile="${POLICY_DB_ROOT}/${SEND_MEMBER_DIR}/send_member_group.conf"
	#PdSendMemberTest $pdConfigFile "#63-Policy group send member"

	# User send_member test
	#local pdConfigFile="${POLICY_DB_ROOT}/${SEND_MEMBER_DIR}/send_member_user.conf"
	#PdSendMemberTest $pdConfigFile "#64-Policy user send member"

	# Default send_member wildcard test
	local pdConfigFile="${POLICY_DB_ROOT}/${SEND_MEMBER_DIR}/send_member_wildcard_default.conf"
	PdSendMemberTest $pdConfigFile "#65-Policy default send member wildcard"

	# Mandatory send_member wildcard test
	local pdConfigFile="${POLICY_DB_ROOT}/${SEND_MEMBER_DIR}/send_member_wildcard_mandatory.conf"
	PdSendMemberTest $pdConfigFile "#66-Policy mandatory send member wildcard"

	# Group send_member wildcard test
	#local pdConfigFile="${POLICY_DB_ROOT}/${SEND_MEMBER_DIR}/send_member_wildcard_group.conf"
	#PdSendMemberTest $pdConfigFile "#67-Policy group send member wildcard"

	# User send_member wildcard test
	#local pdConfigFile="${POLICY_DB_ROOT}/${SEND_MEMBER_DIR}/send_member_wildcard_user.conf"
	#PdSendMemberTest $pdConfigFile "#68-Policy user send member wildcard"
}
# Function name: TestRecvMember
# Description: run policy db receive_member related tests
# Parameter: none
# Return: none
function TestRecvMember() {
	echo "Run policy db receive_member tests..." >> $testDetailLog

	# Default receive_member test
	local pdConfigFile="${POLICY_DB_ROOT}/${RECV_MEMBER_DIR}/recv_member_default.conf"
	PdSendMemberTest $pdConfigFile "#69-Policy default recv member" 0

	# Mandatory receive_member test
	local pdConfigFile="${POLICY_DB_ROOT}/${RECV_MEMBER_DIR}/recv_member_mandatory.conf"
	PdSendMemberTest $pdConfigFile "#70-Policy mandatory recv member" 0

	# Group receive_member test
	#local pdConfigFile="${POLICY_DB_ROOT}/${RECV_MEMBER_DIR}/recv_member_group.conf"
	#PdSendMemberTest $pdConfigFile "#71-Policy group recv member" 0

	# User receive_member test
	#local pdConfigFile="${POLICY_DB_ROOT}/${RECV_MEMBER_DIR}/recv_member_user.conf"
	#PdSendMemberTest $pdConfigFile "#72-Policy user recv member" 0

	# Default receive_member wildcard test
	local pdConfigFile="${POLICY_DB_ROOT}/${RECV_MEMBER_DIR}/recv_member_wc_default.conf"
	PdSendMemberTest $pdConfigFile "#73-Policy default recv member wildcard" 0

	# Mandatory receive_member wildcard test
	local pdConfigFile="${POLICY_DB_ROOT}/${RECV_MEMBER_DIR}/recv_member_wc_mandatory.conf"
	PdSendMemberTest $pdConfigFile "#74-Policy mandatory recv member wildcard" 0

	# Group receive_member wildcard test
	#local pdConfigFile="${POLICY_DB_ROOT}/${RECV_MEMBER_DIR}/recv_member_wc_group.conf"
	#PdSendMemberTest $pdConfigFile "#75-Policy group recv member wildcard" 0

	# User receive_member wildcard test
	#local pdConfigFile="${POLICY_DB_ROOT}/${RECV_MEMBER_DIR}/recv_member_wc_user.conf"
	#PdSendMemberTest $pdConfigFile "#76-Policy user recv member wildcard" 0
}

# Function name: pdSendErrorTest
# Description: run policy db send error related tests
# Parameter: 
#	pd_config - policy db daemon config file
#	testDesc - test case number and description
# Return: 
#	testResult is 0 if pass; 6 fail; 3 block
function pdSendErrorTest() {
	local pd_config=$1
	local testDesc=$2

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase($testDesc)"
	echo "Test case=$testCase($testDesc)">> $testResultFile
	echo "<p>Test case=$testCase($testDesc)</p>">> $testResultHtml

	# Config file must exist and not empty
	if [ -e "$pd_config" -a -s "$pd_config" ]; then

		# Extract allowed/denied erorrs from config file
		extractNames $pd_config "<allow send_error" "<deny send_error"

		# Run test iff policy db config file is valid
		if [ "$extractStatus" -eq 0 ]; then
			
			# Stop all alljoyn processes
			clean_up_all

			# Launch standard-alone daemon
			local daemonLog="policy_db_daemon_${testCase}.log"
			launchProcess "alljoyn-daemon" "$pd_config" $daemonLog "" $POLICYDB_TEST 1 ""

			sleep 1

			echo "Launching policyService"
			# Launch policyService with allowed name
			local serviceLog="policy_service_${testCase}.log"
			launchProcess "policyService" "" $serviceLog "" $POLICYDB_TEST 1 ""

			sleep 1

			echo "Launching policyClientAll"
			# Launch policyClientAll
			local clientLog="policy_clientall_${testCase}.log"
			launchProcess "policyClientAll" "" $clientLog "" $POLICYDB_TEST 1 ""
	
			# Wait policyClientAll to complete
			sleep 100

			# Stop all alljoyn processes
			clean_up_all
			
			# Check client log has only one org.alljoyn.Bus.Timeout
			echo "check if denied send_error=$deniedName applied"

			local errMethod=`echo $deniedName | sed "s/\.err/Err/"`
			echo "Expected error method name=${errMethod}"

			local errMsg="${errMethod}.*Timeout"

			decideUnitTest $clientLog "$errMsg"
			local allowError=$testResult

			# Other method calls and error calls should NOT timeout
			logHasKeysExactTimes $clientLog "Timeout" 1
			local noOtherError=$matchResult

			if [ "$allowError" -eq 0 -a "$noOtherError" -eq 0 ]; then		
				testResults[totalTests]=0
				echo "Test result=Pass" >> $testResultFile
				echo "<p>Test result=Pass</p>" >> $testResultHtml
			elif [ "$allowError" -ne 0 ]; then
			    local clientError="policy_clientall_${testCase}_error.txt"
			    mv $clientLog $clientError
				testResults[totalTests]=6
				echo "Test result=Fail(Deny rule)" >> $testResultFile
				echo "<p>Test result=Fail(<a class="error" href="\"$clientError\"">Deny rule</a>)</p>" >> $testResultHtml
			else
			    local clientError="policy_clientall_${testCase}_error.txt"
			    mv $clientLog $clientError
				testResults[totalTests]=6
				echo "Test result=Fail(Allow rule)" >> $testResultFile
				echo "<p>Test result=Fail(<a class="error" href="\"$clientError\"">Allow rule</a>)</p>" >> $testResultHtml
			fi
		else
			testResults[totalTests]=3
			echo "Test result=Block(Config parse)" >> $testResultFile
			echo "<p>Test result=Block(Config parse)</p>" >> $testResultHtml
		fi

	else
		echo "Not exist or empty $pd_config , test block!"
		testResults[totalTests]=3
		echo "Test result=Block(Config file)" >> $testResultFile
	fi

	# Increse test count
	totalTests=$(($totalTests + 1))	
}
# Function name: TestSendError
# Description: run policy db send_error related tests
# Parameter: none
# Return: none
function TestSendError() {
	echo "Run policy db send_error tests..." >> $testDetailLog

	# Default send_error test
	local pdConfigFile="${POLICY_DB_ROOT}/${SEND_ERROR_DIR}/send_error_default.conf"
	pdSendErrorTest $pdConfigFile "#95-Policy default send error"

	# Mandatory send_error test
	local pdConfigFile="${POLICY_DB_ROOT}/${SEND_ERROR_DIR}/send_error_mandatory.conf"
	pdSendErrorTest $pdConfigFile "#96-Policy mandatory send error"

	# Group send_error test
	#local pdConfigFile="${POLICY_DB_ROOT}/${SEND_ERROR_DIR}/send_error_group.conf"
	#pdSendErrorTest $pdConfigFile "#97-Policy group send error"

	# User send_error test
	#local pdConfigFile="${POLICY_DB_ROOT}/${SEND_ERROR_DIR}/send_error_user.conf"
	#pdSendErrorTest $pdConfigFile "#98-Policy user send error"

	# Default wildcard send_error test
	local pdConfigFile="${POLICY_DB_ROOT}/${SEND_ERROR_DIR}/send_error_wildcard_default.conf"
	pdSendErrorTest $pdConfigFile "#99-Policy default wildcard send error"

	# Mandatory wildcard send_error test
	local pdConfigFile="${POLICY_DB_ROOT}/${SEND_ERROR_DIR}/send_error_wildcard_mandatory.conf"
	pdSendErrorTest $pdConfigFile "#100-Policy mandatory wildcard send error"

	# Group wildcard send_error test
	#local pdConfigFile="${POLICY_DB_ROOT}/${SEND_ERROR_DIR}/send_error_wildcard_group.conf"
	#pdSendErrorTest $pdConfigFile "#101-Policy group wildcard send error"

	# User wildcard send_error test
	#local pdConfigFile="${POLICY_DB_ROOT}/${SEND_ERROR_DIR}/send_error_wildcard_user.conf"
	#pdSendErrorTest $pdConfigFile "#102-Policy user wildcard send error"
}
# Function name: pdRecvErrorTest
# Description: run policy db receive error related tests
# Parameter: 
#	pd_config - policy db daemon config file
#	testDesc - test case number and description
# Return: 
#	testResult is 0 if pass; 6 fail; 3 block
function pdRecvErrorTest() {
	local pd_config=$1
	local testDesc=$2

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase($testDesc)"
	echo "Test case=$testCase($testDesc)">> $testResultFile
	echo "<p>Test case=$testCase($testDesc)</p>">> $testResultHtml

	# Config file must exist and not empty
	if [ -e "$pd_config" -a -s "$pd_config" ]; then

		# Extract allowed/denied erorrs from config file
		extractNames $pd_config "<allow receive_error" "<deny receive_error"

		# Run test iff policy db config file is valid
		if [ "$extractStatus" -eq 0 ]; then
			# Stop all alljoyn processes
			clean_up_all

			# Launch standard-alone daemon
			local daemonLog="policy_db_daemon_${testCase}.log"
			launchProcess "alljoyn-daemon" "$pd_config" $daemonLog "" $POLICYDB_TEST 1 ""

			sleep 1

			echo "Launching policyService"
			# Launch policyService with allowed name
			local serviceLog="policy_service_${testCase}.log"
			launchProcess "policyService" "" $serviceLog "" $POLICYDB_TEST 1 ""

			sleep 1

			echo "Launching policyClientAll"
			# Launch policyClientAll
			local clientLog="policy_clientall_${testCase}.log"
			launchProcess "policyClientAll" "" $clientLog "" $POLICYDB_TEST 1 ""
	
			# Wait policyClientAll to complete
			sleep 100

			# Stop all alljoyn processes
			clean_up_all
			
			# Check client log has only one org.alljoyn.Bus.Timeout
			echo "check if denied send_error=$deniedName applied"

			local errMethod=`echo $deniedName | sed "s/\.err/Err/"`
			echo "Expected error method name=${errMethod}"

			local errMsg="${errMethod}.*Timeout"

			decideUnitTest $clientLog "$errMsg"
			local allowError=$testResult

			# Other method calls and error calls should NOT timeout
			logHasKeysExactTimes $clientLog "Timeout" 1
			local noOtherError=$matchResult

			if [ "$allowError" -eq 0 -a "$noOtherError" -eq 0 ]; then		
				testResults[totalTests]=0
				echo "Test result=Pass" >> $testResultFile
				echo "<p>Test result=Pass</p>" >> $testResultHtml
			elif [ "$allowError" -ne 0 ]; then
    			local clientError="policy_clientall_${testCase}_error.txt"
    			mv $clientLog $clientError
				testResults[totalTests]=6
				echo "Test result=Fail(Deny rule)" >> $testResultFile
				echo "<p>Test result=Fail(<a class="error" href="\"$clientError\"">Deny rule</a>)</p>" >> $testResultHtml
			else
			    local clientError="policy_clientall_${testCase}_error.txt"
    			mv $clientLog $clientError
				testResults[totalTests]=6
				echo "Test result=Fail(Allow rule)" >> $testResultFile
				echo "<p>Test result=Fail(<a class="error" href="\"$clientError\"">Allow rule</a>)</p>" >> $testResultHtml
			fi
		else
			testResults[totalTests]=3
			echo "Test result=Block(Config parse)" >> $testResultFile
			echo "<p>Test result=Block(Config file ${pd_config} parse error)</p>" >> $testResultHtml
		fi

	else
		echo "Not exist or empty $pd_config , test block!"
		testResults[totalTests]=3
		echo "Test result=Block(Config file ${pd_config} miss)" >> $testResultFile
		echo "<p>Test result=Block(Config file ${pd_config} miss)</p>" >> $testResultHtml
	fi

	# Increse test count
	totalTests=$(($totalTests + 1))	
}
# Function name: TestRecvError
# Description: run policy db receive_error related tests
# Parameter: none
# Return: none
function TestRecvError() {
	echo "Run policy db receive_error tests..." >> $testDetailLog

	# Default receive_error test
	local pdConfigFile="${POLICY_DB_ROOT}/${RECV_ERROR_DIR}/recv_error_default.conf"
	pdRecvErrorTest $pdConfigFile "#103-Policy default receive error"

	# Mandatory receive_error test
	local pdConfigFile="${POLICY_DB_ROOT}/${RECV_ERROR_DIR}/recv_error_mandatory.conf"
	pdRecvErrorTest $pdConfigFile "#104-Policy mandatory receive error"

	# Group receive_error test
	#local pdConfigFile="${POLICY_DB_ROOT}/${RECV_ERROR_DIR}/recv_error_group.conf"
	#pdRecvErrorTest $pdConfigFile "#105-Policy group receive error"

	# User receive_error test
	#local pdConfigFile="${POLICY_DB_ROOT}/${RECV_ERROR_DIR}/recv_error_user.conf"
	#pdRecvErrorTest $pdConfigFile "#106-Policy user receive error"

	# Default wildcard receive_error test
	local pdConfigFile="${POLICY_DB_ROOT}/${RECV_ERROR_DIR}/recv_error_wildcard_default.conf"
	pdRecvErrorTest $pdConfigFile "#107-Policy default wildcard receive error"

	# Mandatory wildcard receive_error test
	local pdConfigFile="${POLICY_DB_ROOT}/${RECV_ERROR_DIR}/recv_error_wildcard_mandatory.conf"
	pdRecvErrorTest $pdConfigFile "#108-Policy mandatory wildcard receive error"

	# Group wildcard receive_error test
	#local pdConfigFile="${POLICY_DB_ROOT}/${RECV_ERROR_DIR}/recv_error_wildcard_group.conf"
	#pdRecvErrorTest $pdConfigFile "#109-Policy group wildcard receive error"

	# User wildcard receive_error test
	#local pdConfigFile="${POLICY_DB_ROOT}/${RECV_ERROR_DIR}/recv_error_wildcard_user.conf"
	#pdRecvErrorTest $pdConfigFile "#110-Policy user wildcard receive error"
}
# Function name: logHasKeysExactTimes
# Description: 
#	Check if test log includes keys exact times
# Parameter:
#	logName
#	passKey
#	count
# Return: 
#	matchResult will be set to 0 if pass; 6 if fail
function logHasKeysExactTimes() {
	local logName=$1
	local passKey=$2
	local count=$3
	
	local actualTimes=0

	$verbose && echo "Deciding test result in $logName with $passKey..." >> $testDetailLog

	matchResult=6
	
	if [ -n "$logName" -a -n "$passKey" ]; then
		if [ -e "$logName" -a -s "$logName" ]; then
			actualTimes=`grep "$passKey" $logName|wc -l`

			if [ "$actualTimes" -eq "$count" ]; then
				matchResult=0
				echo "Log looks OK"
			else

				# Test fail
				echo "Log $logName miss $passKey !" >> $testProgressLog
			fi
		else
			echo "Empty or non-exist file $logName !" >> $testDetailLog
			echo "Empty or non-exist file $logName !" >> $testProgressLog
		fi
	else
		echo "File $logName or key $passKey is null !" >> $testDetailLog
		echo "File $logName or key $passKey is null !" >> $testProgressLog
	fi
}
# Function name: pdSendTypeTest
# Description: run policy db send type related tests
# Parameter: 
#	pd_config - policy db daemon config file
#	testDesc - test case number and description
# Return: 
#	testResult is 0 if pass; 6 fail; 3 block
function pdSendTypeTest() {
	local pd_config=$1
	local testDesc=$2

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase($testDesc)"
	echo "Test case=$testCase($testDesc)">> $testResultFile
	echo "<p>Test case=$testCase($testDesc)</p>">> $testResultHtml

	# Config file must exist and not empty
	if [ -e "$pd_config" -a -s "$pd_config" ]; then

		# Extract allowed/denied type from config file
		extractNames $pd_config "<allow send_type" "<deny send_type"

		# Run test iff policy db config file is valid
		if [ "$extractStatus" -eq 0 ]; then
			
			# Stop all alljoyn processes
			clean_up_all

			# Launch standard-alone daemon
			local daemonLog="policy_db_daemon_${testCase}.log"
			launchProcess "alljoyn-daemon" "$pd_config" $daemonLog "" $POLICYDB_TEST 1 ""

			sleep 1

			echo "Launching policyService"
			# Launch policyService with allowed name
			local serviceLog="policy_service_${testCase}.log"
			launchProcess "policyService" "" $serviceLog "" $POLICYDB_TEST 1 ""

			sleep 1

			echo "Launching policyClientAll"
			# Launch policyClientAll
			local clientLog="policy_clientall_${testCase}.log"
			launchProcess "policyClientAll" "" $clientLog "" $POLICYDB_TEST 1 ""
	
			if [ "$deniedName" == "signal" ]; then
				# deny signal client can still send quickly
				sleep 20
			else
				# Wait policyClientAll to timeout errors or methods
				sleep 480
			fi

			# Stop all alljoyn processes
			clean_up_all
			
			# Check client log
			echo "check if deny send_type=$deniedName applied"

			local denyResult=6

			# If deny signal, then service can't receive signal
			if [ "$deniedName" == "signal" ]; then
				echo "All signals should NOT received by service"
				logHasKeysExactTimes $serviceLog "$RECEIVESIGNAL" 0
				denyResult=$matchResult
			elif [ "$deniedName" == "error" -o "$deniedName" == "method_return" ]; then
				echo "All method returns or error returns timeout"
				# all 8 errors or all 8 methods should Timeout
				logHasKeysExactTimes $clientLog "Timeout" 8
				denyResult=$matchResult
			else
				echo "Service exit ER_BUS_NOT_CONNECTED"
				# service exit with error
				logHasKeysExactTimes $serviceLog "${POLICY_SERVICE_OK}" 0
				denyResult=$matchResult
			fi

			if [ "$denyResult" -eq 0 ]; then		
				testResults[totalTests]=0
				echo "Test result=Pass" >> $testResultFile
			else
			    local clientError="policy_clientall_${testCase}_error.txt"
			    mv $clientLog $clientError
				testResults[totalTests]=6
				echo "Test result=Fail(Deny rule)" >> $testResultFile
				echo "<p>Test result=Fail(<a class="error" href="\"$clientError\"">Deny rule</a>)</p>" >> $testResultHtml
			fi
		else
			testResults[totalTests]=3
			echo "Test result=Block(Config parse)" >> $testResultFile
			echo "<p>Test result=Block(Config file ${pd_config} parse error)</p>" >> $testResultHtml
		fi

	else
		echo "Not exist or empty $pd_config , test block!"
		testResults[totalTests]=3
		echo "Test result=Block(Config file ${pd_config} miss)" >> $testResultFile
		echo "<p>Test result=Block(Config file ${pd_config} miss)</p>" >> $testResultHtml
	fi

	# Increse test count
	totalTests=$(($totalTests + 1))	
}
# Function name: pdRecvTypeTest
# Description: run policy db receive type related tests
# Parameter: 
#	pd_config - policy db daemon config file
#	testDesc - test case number and description
# Return: 
#	testResult is 0 if pass; 6 fail; 3 block
function pdRecvTypeTest() {
	local pd_config=$1
	local testDesc=$2

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))

	# Leave an empty line between tests in report
	echo >> $testResultFile
    echo "<br>" >> $testResultHtml
    
	echo "Test case=$testCase($testDesc)"
	echo "Test case=$testCase($testDesc)">> $testResultFile
	echo "<p>Test case=$testCase($testDesc)</p>">> $testResultHtml

	# Config file must exist and not empty
	if [ -e "$pd_config" -a -s "$pd_config" ]; then

		# Extract allowed/denied type from config file
		extractNames $pd_config "<allow receive_type" "<deny receive_type"

		# Run test iff policy db config file is valid
		if [ "$extractStatus" -eq 0 ]; then

			# Stop all alljoyn processes
			clean_up_all	

			# Launch standard-alone daemon
			local daemonLog="policy_db_daemon_${testCase}.log"
			launchProcess "alljoyn-daemon" "$pd_config" $daemonLog "" $POLICYDB_TEST 1 ""

			sleep 1

			echo "Launching policyService"
			# Launch policyService with allowed name
			local serviceLog="policy_service_${testCase}.log"
			launchProcess "policyService" "" $serviceLog "" $POLICYDB_TEST 1 ""

			sleep 1

			echo "Launching policyClientAll"
			# Launch policyClientAll
			local clientLog="policy_clientall_${testCase}.log"
			launchProcess "policyClientAll" "" $clientLog "" $POLICYDB_TEST 1 ""
	
			if [ "$deniedName" == "signal" ]; then
				# deny signal client can still send quickly
				sleep 20
			else
				# Wait policyClientAll to timeout errors or methods
				sleep 480
			fi

			# Stop all alljoyn processes
			clean_up_all
			
			# Check client log
			echo "check if deny send_type=$deniedName applied"

			local denyResult=6

			# If deny signal, then service can't receive signal
			if [ "$deniedName" == "signal" ]; then
				echo "All signals should NOT received by service"
				logHasKeysExactTimes $serviceLog "$RECEIVESIGNAL" 0
				denyResult=$matchResult
			elif [ "$deniedName" == "error" -o "$deniedName" == "method_return" ]; then
				echo "All method returns or error returns timeout"
				# all 8 errors or all 8 methods should Timeout
				logHasKeysExactTimes $clientLog "Timeout" 8
				denyResult=$matchResult
			else
				echo "Service exit ER_BUS_NOT_CONNECTED"
				# service exit with error
				logHasKeysExactTimes $serviceLog "${POLICY_SERVICE_OK}" 0
				denyResult=$matchResult
			fi

			if [ "$denyResult" -eq 0 ]; then		
				testResults[totalTests]=0
				echo "Test result=Pass" >> $testResultFile
				echo "<p>Test result=Pass</p>" >> $testResultHtml
			else
			    local clientError="policy_clientall_${testCase}_error.txt"
			    mv $clientLog $clientError
				testResults[totalTests]=6
				echo "Test result=Fail(Deny rule)" >> $testResultFile
				echo "<p>Test result=Fail(<a class="error" href="\"$clientError\"">Deny rule</a>)</p>" >> $testResultHtml
			fi
		else
			testResults[totalTests]=3
			echo "Test result=Block(Config file ${pd_config} parse error)" >> $testResultFile
			echo "<p>Test result=Block(Config file ${pd_config} parse error)</p>" >> $testResultHtml
		fi

	else
		echo "Not exist or empty $pd_config , test block!"
		testResults[totalTests]=3
		echo "Test result=Block(Config file ${pd_config} miss)" >> $testResultFile
		echo "<p>Test result=Block(Config file ${pd_config} miss)</p>" >> $testResultHtml
	fi

	# Increse test count
	totalTests=$(($totalTests + 1))	
}
# Function name: TestSendType
# Description: run policy db send_type related tests
# Parameter: none
# Return: none
function TestSendType() {
	echo "Run policy db send_type tests..." >> $testDetailLog

	# Default send_type test
	local pdConfigFile="${POLICY_DB_ROOT}/${SEND_TYPE_DIR}/send_type_default.conf"
	pdSendTypeTest $pdConfigFile "#77-Policy default send type"

	# Mandatory wildcard send_type test
	local pdConfigFile="${POLICY_DB_ROOT}/${SEND_TYPE_DIR}/send_type_wildcard_mandatory.conf"
	pdSendTypeTest $pdConfigFile "#82-Policy mandatory wildcard send type"

}
# Function name: TestRecvType
# Description: run policy db send_type related tests
# Parameter: none
# Return: none
function TestRecvType() {
	echo "Run policy db receive_type tests..." >> $testDetailLog

	# Default send_type test
	local pdConfigFile="${POLICY_DB_ROOT}/${RECV_TYPE_DIR}/recv_type_default.conf"
	pdRecvTypeTest $pdConfigFile "#85-Policy default receive type"

	# Mandatory wildcard send_type test
	local pdConfigFile="${POLICY_DB_ROOT}/${RECV_TYPE_DIR}/recv_type_wildcard_mandatory.conf"
	pdRecvTypeTest $pdConfigFile "#90-Policy mandatory wildcard receive type"

}

# Function name: slsTest
# Description: run slsemitter and slsreceiver test
# Parameter: 
#  transport - tcp
# Return: 
#	testResult is 0 if pass; 6 fail
function slsTest() {
	local transport=$1

	$verbose && echo "slsemitter/slsreceiver test..." >> $testDetailLog

	# Initialize result to success
	testResults[totalTests]=0

	# Test case start from 1
	local testCase=$(($totalTests + 1))
	
	# Leave an empty line between tests in report
	echo >> $testResultFile
	echo "<br>" >> $testResultHtml
	
	echo "Test case=$testCase(slsemitter/slsreceiver test)"
	echo "Test case=$testCase(slsemitter/slsreceiver test)">> $testResultFile
	echo "<p>Test case=$testCase(slsemitter/slsreceiver test)</p>">> $testResultHtml

	local emitterLog="${testDetailDir}${scriptName}_${testCase}_slsemitter.log"
	local receiverLog="${testDetailDir}${scriptName}_${testCase}_slsreceiver.log"

	local emitterError="${testDetailDir}${scriptName}_${testCase}_slsemitter_error.txt"
	local receiverError="${testDetailDir}${scriptName}_${testCase}_slsreceiver_error.txt"
	
	# Stop existing slsemitter and slsreceiver
	killProcess "${SLS_EMITTER_NAME}"

	killProcess "${SLS_RECEIVER_NAME}"

	# Launch slsreceiver 
	launchProcess "${SLS_RECEIVER_NAME}" "" $receiverLog $transport 0 1 ""

	# Make sure slsemitter is launched
	sleep 2

	# Confirm only one process is launched
	checkProcessCount "${SLS_RECEIVER_NAME}" 1	
	local receiverCount=$processCount

	# slsemitter -r 30000 means emit sls every 30 seconds
	launchProcess "${SLS_EMITTER_NAME}" "" $emitterLog $transport 0 1 "-r 30000"

	# Make sure slsemitter is launched
	sleep 2

	# Confirm only one process is launched
	checkProcessCount "${SLS_EMITTER_NAME}" 1	
	local emitterCount=$processCount

	if [ "$emitterCount" -ne 1 ]; then
		echo "slsemitter launch failure" >> $testErrorLog
		testResults[totalTests]=6
		echo "Test result=Fail(slsemitter crash)" >> $testResultFile
		echo "<p>Test result=Fail(slsemitter crash)</p>" >> $testResultHtml
	elif [ "$receiverCount" -ne 1 ]; then
		echo "slsreceiver launch failure" >> $testErrorLog
		testResults[totalTests]=6
		echo "Test result=Fail(slsreceiver crash)" >> $testResultFile
		echo "<p>Test result=Fail(slsreceiver crash)</p>" >> $testResultHtml
    
	else
		# Wait 5 min to receive some signals
		sleep 300

		# Receiver should receive at least 300/30 - 1 = 9 signals
		local sendKey="SendSignal #:"
		local receiveKey="RxSignal:"

		if [ -e "$emitterLog" -a -e "$receiverLog" ]; then
			local signalsSent=`grep "$sendKey" $emitterLog|wc -l`
			local signalsRecvd=`grep "$receiveKey" $receiverLog|wc -l`

			local missedSignals=$(($signalsSent - $signalsRecvd))

			# (300/30)
			local minSignalsSent=10

			if [ "$signalsSent" -ge "$minSignalsSent" ]; then		
				if [ "$missedSignals" -lt 2 ]; then
					# it is ok to miss one signal
					testResults[totalTests]=0
					echo "Test result=Pass" >> $testResultFile
				else				
				    mv 	$receiverLog $receiverError
					echo "slsreceiver miss $missedSignals signals" >> $testErrorLog
					testResults[totalTests]=6
					echo "Test result=Fail(slsreceiver miss ${missedSignals}/${signalsSent} signals)" >> $testResultFile
					echo "<p>Test result=Fail(slsreceiver <a class="error" href="\"$receiverError\"">miss</a> ${missedSignals}/${signalsSent} signals )</p>" >> $testResultHtml
				fi
			else
			    mv 	$emitterLog $emitterError
				local unSentSignals=$(($minSignalsSent - $signalsSent))
				echo "slsemitter unsent $unSentSignals signals" >> $testErrorLog

				testResults[totalTests]=6
				echo "Test result=Fail(slsemitter unsent $unSentSignals signals)" >> $testResultFile
				echo "<p>Test result=Fail(slsemitter <a class="error" href="\"$emitterError\"">unsent</a> $unSentSignals signals )</p>" >> $testResultHtml
			fi
		else
			echo "slsemitter or slsreceiver log empty" >> $testErrorLog

			testResults[totalTests]=6
			echo "Test result=Fail(empty log)" >> $testResultFile
			echo "<p>Test result=Fail(empty log)</p>" >> $testResultHtml
		fi
	fi

	# Cleanup
	killProcess "${SLS_EMITTER_NAME}"

	killProcess "${SLS_RECEIVER_NAME}"

	sleep 2

	# Increse test count
	totalTests=$(($totalTests + 1))	
}

# Function name: runSessionsTests
# Description: 
#   run sessions interaction tests using tcl/tk/expect script
# Parameter: none
# Return: 
#	testResult is 0 if pass; 6 fail
function runSessionsTests() {

	$verbose && echo "sessions interaction tests..." >> $testDetailLog

	local expectScript="${expectScriptDir}/sessions_test.exp"
	
	if [ -d "${expectScriptDir}" -a -x "${expectScript}" ]; then

	    # Initialize result to success
	    testResults[totalTests]=0

	    # Test case start from 1
	    local testCase=$(($totalTests + 1))
	
	    # Leave an empty line between tests in report
	    echo >> $testResultFile
        echo "<br>" >> $testResultHtml
        
	    echo "Test case=$testCase(point-point sessions test)"
	    echo "Test case=$testCase(point-point sessions test)">> $testResultFile
        echo "<p>Test case=$testCase(point-point sessions test)</p>">> $testResultHtml
        
	    local p2pLog="${testDetailDir}${scriptName}_${testCase}_sessions_p2p.log"
        local p2pHtml="${testDetailDir}${scriptName}_${testCase}_sessions_p2p_error.txt"
        
	    # Stop existing sessions
	    killProcess "sessions"

	    # Launch p2pSessionsTest 
	    timeout 90 $expectScript $LinuxBinDir p2p >$p2pLog 2>&1
        local p2pResult=$?
        
        if [ "$p2pResult" -eq 0 ]; then
            testResults[totalTests]=0
			echo "Test result=Pass" >> $testResultFile
			echo "<p>Test result=Pass</p>" >> $testResultHtml
	    else
	        mv $p2pLog $p2pHtml
	        testResults[totalTests]=6
		    echo "Test result=Fail(Step${p2pResult} in $p2pLog )" >> $testResultFile
		    echo "<p>Test result=Fail(Step${p2pResult} in <a class="error" href="\"$p2pHtml\"">log</a> )</p>" >> $testResultHtml
		fi

	    # Increse test count
	    totalTests=$(($totalTests + 1))
	    
	    # Initialize result to success
	    testResults[totalTests]=0

	    # Test case start from 1
	    testCase=$(($totalTests + 1))
	
	    # Leave an empty line between tests in report
	    echo >> $testResultFile
        echo "<br>" >> $testResultHtml
        
	    echo "Test case=$testCase(multi-point sessions test)"
	    echo "Test case=$testCase(multi-point sessions test)">> $testResultFile
        echo "<p>Test case=$testCase(multi-point sessions test)</p>">> $testResultHtml
        
	    local sessionsMpLog="sessions_mp.log"
        local sessionsMpError="sessions_mp_error.txt"
        
	    # Stop existing sessions
	    killProcess "sessions"

	    # Launch mpSessionsTest 
	    timeout 120 $expectScript $LinuxBinDir mp >$sessionsMpLog 2>&1
        local mpResult=$?
        
        if [ "$mpResult" -eq 0 ]; then
            testResults[totalTests]=0
			echo "Test result=Pass" >> $testResultFile
			echo "<p>Test result=Pass</p>" >> $testResultHtml
	    else
	        mv $sessionsMpLog $sessionsMpError
	        testResults[totalTests]=6
		    echo "Test result=Fail(Step${mpResult} in  $sessionsMpLog )" >> $testResultFile
		    echo "<p>Test result=Fail(Step${mpResult} in <a class="error" href="\"$sessionsMpError\"">log</a> )</p>" >> $testResultHtml
		fi

	    # Increse test count
	    totalTests=$(($totalTests + 1))
	
		# Initialize result to success
	    testResults[totalTests]=0
	    
		# Test case start from 1
	    testCase=$(($totalTests + 1))
	    
	    # Leave an empty line between tests in report
	    echo >> $testResultFile
        echo "<br>" >> $testResultHtml
        
	    echo "Test case=$testCase(bind,unbind,join,rejoin multi-point session)"
	    echo "Test case=$testCase(bind,unbind,join,rejoin multi-point session)">> $testResultFile
        echo "<p>Test case=$testCase(bind,unbind,join,rejoin multi-point session)</p>">> $testResultHtml
        
	    local mpUnbindLog="sessions_mp_unbind.log"
        local mpUnbindError="sessions_mp_unbind_error.txt"
        
	    # Stop existing sessions
	    killProcess "sessions"

	    # Launch mpSessionsTest 
	    timeout 90 $expectScript $LinuxBinDir mp_unbind >$mpUnbindLog 2>&1
        local mpUnbindResult=$?
        
        if [ "$mpUnbindResult" -eq 0 ]; then
            testResults[totalTests]=0
			echo "Test result=Pass" >> $testResultFile
			echo "<p>Test result=Pass</p>" >> $testResultHtml
	    else
	        mv $mpUnbindLog $mpUnbindError
	        testResults[totalTests]=6
		    echo "Test result=Fail(Step${mpUnbindResult} in  $mpUnbindLog )" >> $testResultFile
		    echo "<p>Test result=Fail(Step${mpUnbindResult} in  <a class="error" href="\"$mpUnbindError\"">log</a>)</p>" >> $testResultHtml
		fi

	    # Increse test count
	    totalTests=$(($totalTests + 1))
	else
	    echo "$expectScriptDir or $expectScript missing!" >> $testDetailLog 
	fi
}
# Function name: policyDbTest
# Description: run policy db tests
# Parameter: none
# Return: none
function policyDbTestDbg() {
	echo "Run policy db tests..." >> $testDetailLog

	if [ -d "${POLICYDB_REL_BIN_DIR}" -a -d "${POLICYDB_REL_LIB_DIR}" -a -d "${POLICY_DB_ROOT}" ]; then
		# Run sls related tests
		TestSessionlessSignal

		# Rest tests need policyService and policyClientAll programs
		if [ -x "${POLICY_SERVICE}" -a -x "${POLICY_CLIENTALL}" ]; then
			# Run send_error tests
			TestSendError

			# Run receive_error tests
			TestRecvError

			# Run send_type tests
			TestSendType

			# Run receive_type tests
			TestRecvType
		else
			echo "${POLICY_SERVICE} or ${POLICY_CLIENTALL} NOT exist!" 
			echo "${POLICY_SERVICE} or ${POLICY_CLIENTALL} NOT exist!" >> $testErrorLog
		fi

		# Run name ownership related tests
		TestName

		# Run send_destination related tests
		TestSendDest

		# Run receive-* related tests
		TestRecvSender

		# Run send_member related tests
		TestSendMember
	
		# Run receive_member related tests
		TestRecvMember

	fi

}

# Function name: decideEventClientResult
# Description: check event client log to decide test result
# Parameter: 
#	clientLog     - event client log
#   expectedLog   - expected log to compare with
# Return: 
#	eventClientStatus is 0 if pass; 
#   1 if comparision fail; 2 if log is empty
function decideEventClientResult() {
	echo "check EventClient log..." >> $testDetailLog
	local clientLog=$1
    local expectedLog=$2
    
	eventClientStatus=0	
	local parsedLog="eventClient_parsed.log"
		
	# Check about client log
	# We don't want to check announcement data detail since certification test do that
	# We only check bus connection and announcement from service bus
	if [ -e "$clientLog" -a -s "$clientLog" ]; then
	
	    # Extract between header and tail
	    sed -n -e "/$eventLogHeader/,/$eventLogTail/p" $clientLog >$parsedLog
	    
	    # Compare logs ignore white space and empty line
	    diff -w -B $expectedLog $parsedLog
	    eventClientStatus=$?
	    
        if [ "$eventClientStatus" -eq 0 ]; then
		    echo "Log comparision pass" >> $testErrorLog
		else
		    echo "Log comparision fail!" >> $testErrorLog
		    
		fi
	else
		echo "$clientLog is empty!" >> $testErrorLog
		eventClientStatus=2
	fi
}

# Function name: runEventActionTest
# Description: run event and action test
# Parameter: 
#   serviceOpt  - signal_service launch option(i.e. -g/-b)
#   clientOpt   - nameChange_client launch option
#   expectedLog - expected client log
#   actualLog   - actual client log
#   description - test description
# Return: 
#	testResult is 0 if pass; 6 fail; 5 block
function runEventActionTest() {
	echo "Event/Action..." >> $testDetailLog
    local serviceOpt="$1"
    local clientOpt="$2"
    local expectedLog="$3"
    local actualLog="$4"
    local description="$5"
    
    # Expected client log should exist
    if [ -e "$expectedLog" ]; then
	    # Initialize result to success
	    testResults[totalTests]=0

	    # Test case 
	    local testCase=$(($totalTests + 1))
	    
	    # Leave an empty line between tests in report
	    echo >> $testResultFile
	    echo "<br>" >> $testResultHtml
	
	    echo "Test case=$testCase(EA $description)"
	    echo "Test case=$testCase(EA $description)">> $testResultFile
        echo "<p>Test case=$testCase(EA $description)</p>">> $testResultHtml
    
	    local eventServiceLog="eventservice_${testCase}.log"

	    # Stop existing pre-installed daemon, signal_service and nameChange_client running
	    killProcess "alljoyn-daemon"

	    killProcess "${EVENT_SERVICE_NAME}"

	    killProcess "${EVENT_CLIENT_NAME}"

	    # Launch signal_service with options
	    launchProcess "${EVENT_SERVICE_NAME}" "" $eventServiceLog "" 0 1 "$serviceOpt"

	    # Make sure signal_service is launched
	    sleep 1

	    # Confirm only one process is launched
	    checkProcessCount "${EVENT_SERVICE_NAME}" 1	

	    if [ "$processCount" -ne 1 ]; then
		    echo "signal_service launch failure" >> $testErrorLog
		    testResults[totalTests]=6
		    echo "Test result=Fail(${EVENT_SERVICE_NAME} crash)" >> $testResultFile
		    echo "<p>Test result=Fail(${EVENT_SERVICE_NAME} crash)</p>" >> $testResultHtml
	    else
		    # Launch nameChange_client with options
		    launchProcess "${EVENT_CLIENT_NAME}" "" $actualLog "" 0 1 "$clientOpt"

		    # Make sure joinSession and introspection complete
		    sleep 30

		    # Check eventClient log to decide Pass/Fail
		    decideEventClientResult $actualLog $expectedLog

		    if [ "$eventClientStatus" -eq 0 ]; then
			    testResults[totalTests]=0
			    echo "Test result=Pass" >> $testResultFile
			    echo "<p>Test result=Pass</p>" >> $testResultHtml
		    else
		
			    # Empty EventClient log, test blocked
		        if [ "$eventClientStatus" -eq 2 ]; then
		            testResults[totalTests]=5
			        echo "Test result=Block(Client empty log)" >> $testResultFile
			        echo "<p>Test result=Block(Client empty log)</p>" >> $testResultHtml
			    else
			        local eventclientError="eventclient_${testCase}_error.txt"
		            mv $actualLog $eventclientError
	            
	                testResults[totalTests]=6
			        echo "Test result=Fail(client)" >> $testResultFile
			        echo "<p>Test result=Fail(<a class="error" href="\"$eventclientError\"">client</a>)</p>" >> $testResultHtml

			    fi
		    fi
	    fi

    	# Cleanup
    	killProcess "${EVENT_SERVICE_NAME}"

    	killProcess "${EVENT_CLIENT_NAME}"
    	
    	sleep 2

	    # Increse test count
	    totalTests=$(($totalTests + 1))	
    fi	
}

# Function name: eventActionTests
# Description: run event and action tests
# Parameter: none
# Return: none
function eventActionTests() {
	echo "Run event and action tests..." >> $testDetailLog

    # Event and action test programs are under test tools directory
	if [ -d "${EA_BIN_DIR}" -a -d "${EA_LOG_DIR}" ]; then
	    # signal_service and nameChange_client are test programs
	    if [ -x "${REL_SIGNAL_SERVICE}" -a -x "${REL_NAME_CHANGE_CLIENT}" ]; then
            # Global translator and client using empty string to Introspect 
            expectedClientLog="${EA_LOG_DIR}/global_empty_string.txt"
            actualClientLog="global_empty_string.log"
            testDescription="global translator and client empty string"
            runEventActionTest "-g" "-d" "$expectedClientLog" "$actualClientLog" "$testDescription"
    
            # Global translator and client using unsupported language to Introspect 
            expectedClientLog="${EA_LOG_DIR}/global_unsupport_lang.txt"
            actualClientLog="global_unsupport_lang.log"
            testDescription="global translator and client unsupported language"
            runEventActionTest "-g" "-d -uslang" "$expectedClientLog" "$actualClientLog" "$testDescription"
    
            # Global translator and client using supported language to Introspect 
            expectedClientLog="${EA_LOG_DIR}/global_support_lang.txt"
            actualClientLog="global_support_lang.log"
            testDescription="global translator and client supported language"
            runEventActionTest "-g" "-d -slang" "$expectedClientLog" "$actualClientLog" "$testDescription"
            
            # Bus Object level translator and Client using empty string to Introspect
            expectedClientLog="${EA_LOG_DIR}/bus_empty_string.txt"
            actualClientLog="bus_empty_string.log"
            testDescription="bus Object level translator and client empty string"
            runEventActionTest "-b" "-d" "$expectedClientLog" "$actualClientLog" "$testDescription"
    
            # Bus Object level translator and Client using supported language to Introspect             
            expectedClientLog="${EA_LOG_DIR}/bus_support_lang.txt"
            actualClientLog="bus_support_lang.log"
            testDescription="bus Object level translator and client supported language"
            runEventActionTest "-b" "-d -slang" "$expectedClientLog" "$actualClientLog" "$testDescription"
            
            # Interface level translator and client using empty string to Introspect 
            expectedClientLog="${EA_LOG_DIR}/interface_empty_string.txt"
            actualClientLog="interface_empty_string.log"
            testDescription="interface level translator and client empty string"
            runEventActionTest "-i" "-d" "$expectedClientLog" "$actualClientLog" "$testDescription"
    
            # Interface level translator and client using supported language to Introspect 
            expectedClientLog="${EA_LOG_DIR}/interface_support_lang.txt"
            actualClientLog="interface_support_lang.log"
            testDescription="interface level translator and client supported language"
            runEventActionTest "-i" "-d -slang" "$expectedClientLog" "$actualClientLog" "$testDescription"
            
            # No translator and Client using supported language to Introspect 
            expectedClientLog="${EA_LOG_DIR}/no_translator_support_lang.txt"
            actualClientLog="no_translator_support_lang.log"
            testDescription="no translator and client supported language"
            runEventActionTest "" "-d -slang" "$expectedClientLog" "$actualClientLog" "$testDescription"
    
            # Global translator and Client using no description
            expectedClientLog="${EA_LOG_DIR}/global_no_description.txt"
            actualClientLog="global_no_description.log"
            testDescription="global translator and client no description"
            runEventActionTest "-g" "-wd" "$expectedClientLog" "$actualClientLog" "$testDescription"
            
        elif [ ! -x "${REL_SIGNAL_SERVICE}" ]; then
            echo "EA tests blocked since ${REL_SIGNAL_SERVICE} NOT exist!"
            echo "EA tests blocked since ${REL_SIGNAL_SERVICE} NOT exist!" >> $testResultFile
            echo "<p>EA tests blocked since ${REL_SIGNAL_SERVICE} NOT exist!</p>" >> $testResultHtml
        else
            echo "EA tests blocked since ${REL_NAME_CHANGE_CLIENT} NOT exist!"
            echo "EA tests blocked since ${REL_NAME_CHANGE_CLIENT} NOT exist!" >> $testResultFile
            echo "<p>EA tests blocked since ${REL_NAME_CHANGE_CLIENT} NOT exist!</p>" >> $testResultHtml
        fi
    else
        echo "EA tests blocked since ${EA_BIN_DIR} or ${EA_LOG_DIR} NOT exist!"
        echo "EA tests blocked since ${EA_BIN_DIR} or ${EA_LOG_DIR} NOT exist!" >> $testResultFile
        echo "<p>EA tests blocked since ${EA_BIN_DIR} or ${EA_LOG_DIR} NOT exist!</p>" >> $testResultHtml
    fi 
}

# Function name: runSCTests
# Description: run standard client tests
# Parameter: none
# Return: none
function runSCTests() {
	echo "Run standard client tests..." >> $testDetailLog

    # Event and Action tests 
    eventActionTests
    
    runSessionsTests

	# Run slsemitter and slsreceiver test
	if [ -d "${TOOLS_REL_DIR}" ]; then
		if [ -x "${SLS_EMITTER_BIN}" -a -x "${SLS_RECEIVER_BIN}" ]; then
			# slsemitter and slsreceiver test
			slsTest "tcp"
		elif [ ! -x "${SLS_EMITTER_BIN}" ]; then
			echo "${SLS_EMITTER_BIN} NOT exist!"
			echo "${SLS_EMITTER_BIN} NOT exist!" >> $testErrorLog
		else
			echo "${SLS_RECEIVER_BIN} NOT exist!"
			echo "${SLS_RECEIVER_BIN} NOT exist!" >> $testErrorLog			
		fi
	
		if [ -x "${NGNS_REL_BIN}" ]; then
			echo "Start slsemitter test..."
			# NGNS unit test
			ngnsTest
		else
			echo "NGNS binary ${NGNS_REL_BIN} NOT exist!"
			echo "NGNS binary ${NGNS_REL_BIN} NOT exist!" >> $testErrorLog
		fi
	else
		echo "Test tools release directory ${TOOLS_REL_DIR} NOT exist!"
		echo "Test tools release directory ${TOOLS_REL_DIR} NOT exist!" >> $testErrorLog
	
	fi
	
	# Run policy db debug tests
	policyDbTestDbg

	# Linux rawservice/rawclient test
	rawSocketTest "tcp"

	# Platform independent tests
	runSCIndependent

	# Multipoint session tests
	runMultipointSessions

	# About test apps and samples
	runAboutSamples

	# Run method call test over tcp
	twoDaemonsTest "tcp"

	# Run stress tests
	runSCStress

}

# Clean up old logs
rm *.html *.txt *.log *.conf* *.head >/dev/null 2>&1

#parse input argument
parseCmdArgs $*

# Setup global constants
SetUpGlobalVariables

# Set result directory
setResultDir

echo "Test started..." >> $testDetailLog

#Print test report summary common to all tests
testDate=`eval date +%Y%m%d`
echo "Test date=$testDate" > $testResultFile

# Html format
echo "<html> <style> a.info {color:green} a.error {color:red} </style>" > $testResultHtml
echo "<body>" >> $testResultHtml
echo "<h3>Test date=$testDate </h3>" >> $testResultHtml

# Get core and tc commit id ref from sdk manifest.txt
getCommitIds

if [ "$scCommitId" != "${UNKNOWN_ID}" ]; then
    createCommitIdUrl ${SC_COMMIT_TYPE} "$scCommitId"
    echo "SC commit id=$scCommitId" >> $testResultFile
	echo "<p>SC commit id=<a class="info" href="\"$commitUrl\"">$scCommitId</a></p>" >> $testResultHtml
fi

if [ "$tcCommitId" != "${UNKNOWN_ID}" ]; then
    createCommitIdUrl ${TC_COMMIT_TYPE} "$tcCommitId"
    
    echo "TC commit id=$tcCommitId" >> $testResultFile
	echo "<p>TC commit id=<a class="info" href="\"$commitUrl\"">$tcCommitId</a></p>" >> $testResultHtml
fi

if [ "$testCommitId" != "${UNKNOWN_ID}" ]; then
    createCommitIdUrl ${TEST_COMMIT_TYPE} "$testCommitId"
    
    echo "Test commit id=$testCommitId" >> $testResultFile
	echo "<p>Test commit id=<a class="info" href="\"$commitUrl\"">$testCommitId</a></p>" >> $testResultHtml
fi

echo "......" >> $testResultFile
echo "<p>......</p>" >> $testResultHtml

totalTests=0
passedTest=0
failedTest=0
blockedTest=0

# TC/SC interaction tests
if [ "${LITE_READY}" -eq 1 ]; then
runTcScInteraction
fi

# C binding no longer supported: Linux c-binding samples
#runCSamples

# SC platform independent tests
runSCTests

# Thin Client tests
if [ "${LITE_READY}" -eq 1 ]; then
runLiteTests
fi

passedTest=0
failedTest=0
blockedTest=0

echo "......" >> $testResultFile

echo "Total tests=$totalTests" >> $testResultFile

echo "<p>......</p>" >> $testResultHtml

echo "<p>Total tests=$totalTests</p>" >> $testResultHtml

for (( testCase=0; testCase<$totalTests; testCase++))
do
	currentResult=${testResults[testCase]}

	if [ "$currentResult" -eq 0 ]; then
		passedTest=`expr $passedTest + 1`
	elif [ "$currentResult" -eq 6 ]; then
		failedTest=`expr $failedTest + 1`
	else
		blockedTest=`expr $blockedTest + 1`
	fi
done

echo "Test passed=$passedTest" >> $testResultFile
echo "Test failed=$failedTest" >> $testResultFile
echo "Test blocked=$blockedTest" >> $testResultFile

echo "<p>Test passed=$passedTest</p>" >> $testResultHtml
echo "<p>Test failed=$failedTest</p>" >> $testResultHtml
echo "<p>Test blocked=$blockedTest</p>" >> $testResultHtml
echo "</body>" >> $testResultHtml
echo "</html>" >> $testResultHtml

echo "Test complete, passed $passedTest failed $failedTest, check $testResultFile"

if [ "$failedTest" -eq 0 ]; then
	exit 0
else
	exit 1
fi
